// src/components/Inventory/AddEditProductFormLogic.jsx
import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import axiosInstance from '../../api/axiosInstance';
import { useCurrency } from '../../context/CurrencyContext'; // <-- NUEVA LÍNEA!
import { useDebounce } from '../../hooks/useDebounce'; // <-- NUEVA LÍNEA!
import { useTranslation } from 'react-i18next';
import PropTypes from 'prop-types';
import { toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

// Importación perezosa del componente AddEditProductForm (ahora de UI)
const AddEditProductFormUI = lazy(() => import('./AddEditProductForm'));

const AddEditProductFormLogic = ({
    isNewProduct,
    initialProductData, // Producto inicial para edición o vacío para nuevo
    onProductSave, // Callback para InventoryPage (handleAddProduct o handleUpdateProduct)
    loading,
    displayMessage,
    unitOfMeasureOptions,
    debounceTimeoutRef, // Pasado desde InventoryPage para el debounce
}) => {
    // Estado para manejar el modo de edición (true si es edición, false si es nuevo producto)
    const [isEditing, setIsEditing] = useState(!isNewProduct);
    // Estado para manejar el modo de variantes (true si tiene variantes, false si es un producto simple)
    const [hasVariants, setHasVariants] = useState(isNewProduct ? false : initialProductData?.variants?.length > 0);
    // Estados internos para la lógica del formulario
    const [productData, setProductData] = useState(initialProductData);
    const [autoGeneratedSku, setAutoGeneratedSku] = useState(''); // Se usará para el placeholder
    const [isMainSkuManuallyEdited, setIsMainSkuManuallyEdited] = useState(false); // Indica si el usuario ha editado el SKU manualmente
    const [globalProductSuggestions, setGlobalProductSuggestions] = useState([]);
    const [showGlobalSuggestions, setShowGlobalSuggestions] = useState(false);
    const [noGlobalSuggestionsFound, setNoGlobalSuggestionsFound] = useState(false);
    const [imageFile, setImageFile] = useState(null);
    const [imagePreviewUrl, setImagePreviewUrl] = useState('');
    const [isUploadingMainImage, setIsUploadingMainImage] = useState(false);
    const [variantImageUploading, setVariantImageUploading] = useState({});
    const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
    const [formErrors, setFormErrors] = useState({});

    // --- NUEVOS ESTADOS PARA PORCENTAJE DE GANANCIA DINÁMICO ---
    const [calculatedProductProfitPercentage, setCalculatedProductProfitPercentage] = useState(0);
    const [calculatedProductPricePlaceholder, setCalculatedProductPricePlaceholder] = useState(0);
    const [calculatedVariantProfitPercentage, setCalculatedVariantProfitPercentage] = useState({}); // Porcentaje por variante
    const [calculatedVariantPricePlaceholder, setCalculatedVariantPricePlaceholder] = useState({}); // Placeholder por variante
    // --- FIN NUEVOS ESTADOS ---
    
    // Hook para obtener la moneda base del contexto
    const { baseCurrency } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la tasa de cambio actual del contexto
    const { exchangeRate } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la moneda secundaria del contexto
    const { secondaryCurrency } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la moneda primaria del contexto
    const { primaryCurrency } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la tasa de cambio del contexto
    const { getExchangeRate } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la tasa de cambio del contexto
    const { setExchangeRate } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la moneda secundaria del contexto
    const { setSecondaryCurrency } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la moneda primaria del contexto
    const { setPrimaryCurrency } = useCurrency(); // <-- NUEVA LÍNEA!
    // Hook para obtener la tasa de cambio del contexto
    const { setBaseCurrency } = useCurrency(); // <-- NUEVA LÍNEA
    // NUEVO: Hook para manejar el debounce de las sugerencias globales
    const debounceTimeoutRef = useRef(null);

    // Función para generar un SKU único a partir de un nombre
    // ESTA FUNCIÓN HA SIDO MOVIDA AQUÍ ARRIBA PARA EVITAR EL "ReferenceError"
    const generateSkuFromName = useCallback((name) => {
        if (!name || name.trim() === '') return '';
        const cleanedName = name
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .trim()
            .toUpperCase()
            .split(/\s+/)
            .slice(0, 4)
            .join('-');
        const hash = Math.random().toString(36).substring(2, 6).toUpperCase();
        return `${cleanedName.substring(0, 15)}-${hash}`;
    }, []);

    // NUEVO: Función para calcular el porcentaje de ganancia y el precio placeholder
    const calculateProfitAndPricePlaceholder = useCallback((costPrice, price, costCurrency, saleCurrency, setProfitPercentage, setPricePlaceholder) => {
        if (costPrice <= 0 || price <= 0) {
            setProfitPercentage(0);
            setPricePlaceholder(0);
            return;
        }
        const profit = price - costPrice;
        const profitPercentage = ((profit / costPrice) * 100).toFixed(2);
        const pricePlaceholder = (costPrice + profit).toFixed(2);
        // Actualizar el estado con los valores calculados
        setProfitPercentage(profitPercentage);
        setPricePlaceholder(pricePlaceholder);
    }, []);

    // NUEVO: Efecto para sincronizar el estado interno con las props iniciales
    useEffect(() => {
        // Si no hay datos iniciales, no hacemos nada
        if (!initialProductData) return;
        // Determinar si es un producto nuevo basado en la presencia de initialProductData
        const isNewProduct = !initialProductData || Object.keys(initialProductData).length === 0;
    }, [initialProductData]);

    // Sincroniza el estado interno con las props iniciales (para edición)
useEffect(() => {
    setProductData(prevData => {
        const dataToSet = { ...initialProductData };
        // Si es un producto nuevo, inicializamos con valores por defecto
        if (isNewProduct) {
            dataToSet.name = '';
            dataToSet.description = '';
            dataToSet.category = '';
            dataToSet.sku = '';
            dataToSet.unitOfMeasure = 'unidad';
            dataToSet.brand = '';
            dataToSet.supplier = '';
            dataToSet.imageUrl = '';
            dataToSet.color = '';
            dataToSet.size = '';
            dataToSet.material = '';
            dataToSet.isPerishable = false;
            dataToSet.reorderThreshold = 0;
            dataToSet.optimalMaxStock = 0;
            dataToSet.shelfLifeDays = 0;
            dataToSet.baseCurrency = baseCurrency || 'USD'; // <-- AÑADIDO PARA LA MONEDA BASE
            dataToSet.variants = []; // Inicialmente sin variantes
        }
        // Si es un producto existente, usamos los datos iniciales
        else {
            dataToSet.name = initialProductData.name || '';
            dataToSet.description = initialProductData.description || '';
            dataToSet.category = initialProductData.category || '';
            dataToSet.sku = initialProductData.sku || '';
            dataToSet.unitOfMeasure = initialProductData.unitOfMeasure || 'unidad';
            dataToSet.brand = initialProductData.brand || '';
            dataToSet.supplier = initialProductData.supplier || '';
            dataToSet.imageUrl = initialProductData.imageUrl || '';
            dataToSet.color = initialProductData.color || '';
            dataToSet.size = initialProductData.size || '';
            dataToSet.material = initialProductData.material || '';
            dataToSet.isPerishable = initialProductData.isPerishable || false;
            dataToSet.reorderThreshold = initialProductData.reorderThreshold || 0;
            dataToSet.optimalMaxStock = initialProductData.optimalMaxStock || 0;
            dataToSet.shelfLifeDays = initialProductData.shelfLifeDays || 0;
            dataToSet.baseCurrency = initialProductData.baseCurrency || baseCurrency || 'USD'; // <-- AÑADIDO PARA LA MONEDA BASE
            dataToSet.variants = initialProductData.variants || [];
        }
        // Aseguramos que el SKU sea autogenerado si no se ha editado manualmente
        if (!isMainSkuManuallyEdited) {
            dataToSet.sku = dataToSet.sku.trim() === '' ? generateSkuFromName(dataToSet.name) : dataToSet.sku;
        }
        // Aseguramos que el SKU de las variantes sea autogenerado si no se ha editado manualmente y no tiene SKU
        dataToSet.variants = dataToSet.variants.map(variant => {    
            return {
                ...variant,
                autoGeneratedVariantSku: variant.sku && variant.sku.trim() !== '' ? '' : generateSkuFromName(variant.name || ''),
            }
        // (Remove this stray closing brace to fix the syntax error)
        // Inicializar las nuevas monedas si es un producto nuevo o no las tiene
        dataToSet.costCurrency = dataToSet.costCurrency || 'USD';
        dataToSet.saleCurrency = dataToSet.saleCurrency || 'USD';
        dataToSet.baseCurrency = dataToSet.baseCurrency || 'USD'; // Asegurar que baseCurrency tenga un valor
        dataToSet.displayCurrency = dataToSet.displayCurrency || dataToSet.saleCurrency || 'USD'; // displayCurrency = saleCurrency por defecto
        // Asegurar que los campos de moneda estén en el formato correcto
        dataToSet.costCurrency = dataToSet.costCurrency.toUpperCase();
        dataToSet.saleCurrency = dataToSet.saleCurrency.toUpperCase();
        dataToSet.baseCurrency = dataToSet.baseCurrency.toUpperCase();
        dataToSet.displayCurrency = dataToSet.displayCurrency.toUpperCase();
        // Asegurar que los campos de moneda estén en el formato correcto
        dataToSet.costPrice = dataToSet.costPrice || 0; // Asegurar que costPrice tenga un valor por defecto
        dataToSet.price = dataToSet.price || 0; // Asegurar que price tenga un valor por defecto
        dataToSet.stock = dataToSet.stock || 0; // Asegurar que stock tenga un valor por defecto
        dataToSet.reorderThreshold = dataToSet.reorderThreshold || 0; // Asegurar que reorderThreshold tenga un valor por defecto  
        // Asegurar que los campos de variantes tengan valores por defecto 
        dataToSet.variants = dataToSet.variants.map(variant => ({
            ...variant,
            name: variant.name || '',
            sku: variant.sku || '',
            price: variant.price || 0,
            costPrice: variant.costPrice || 0,
            stock: variant.stock || 0,
            unitOfMeasure: variant.unitOfMeasure || 'unidad',
            imageUrl: variant.imageUrl || '',
            color: variant.color || '',
            size: variant.size || '',
            material: variant.material || '',
            autoGeneratedVariantSku: variant.sku && variant.sku.trim() !== '' ? '' : generateSkuFromName(variant.name || ''),
            isPerishable: variant.isPerishable || false,
            reorderThreshold: variant.reorderThreshold || 0,
            optimalMaxStock: variant.optimalMaxStock || 0,
            shelfLifeDays: variant.shelfLifeDays || 0,
        }));
        // Asegurar que los campos de variantes tengan valores por defecto
        // Si es un producto nuevo, inicializamos los campos de monedas
        // Si es un producto nuevo, inicializamos los campos de monedas
        if (isNewProduct) {
            dataToSet.costCurrency = 'USD';
            dataToSet.saleCurrency = 'USD';
            dataToSet.baseCurrency = 'USD';
            dataToSet.displayCurrency = 'USD';
        }

        // Si es un producto nuevo o un producto existente sin variantes, los campos normales se usan
        // Si es un producto con variantes, ciertos campos del padre deben ser informativos
        if (dataToSet.variants && dataToSet.variants.length > 0) {
            // Forzamos stock, precio, costo, unidad y SKU del padre a valores informativos/neutros
            // ya que serán derivados de las variantes en el pre-save hook del backend
            dataToSet.stock = 0; // Se recalculará en el backend
            dataToSet.price = 0; // Se derivará del primer precio de variante en el backend
            dataToSet.costPrice = 0; // Se derivará del primer costo de variante en el backend
            // SKU y unitOfMeasure no los tocaremos aquí, ya que pueden ser relevantes para el producto padre
            // aunque estén deshabilitados para edición si tiene variantes.
            dataToSet.sku = ''; // Dejar vacío para que el backend lo maneje
            dataToSet.unitOfMeasure = ''; // Dejar vacío para que el backend lo maneje
            dataToSet.variants.forEach(variant => {
                // Aseguramos que cada variante tenga un SKU autogenerado si no se ha editado manualmente
                if (!variant.autoGeneratedVariantSku || variant.sku.trim() === '') {
                    variant.autoGeneratedVariantSku = generateSkuFromName(variant.name || '');
                }
            });
            // Asegurar que las variantes también tengan los nuevos campos de moneda inicializados
            dataToSet.variants = dataToSet.variants.map(v => ({
                ...v,
                costCurrency: v.costCurrency || 'USD',
                saleCurrency: v.saleCurrency || 'USD',
            }));
        } else {
            // Si no hay variantes, aseguramos que los campos de moneda estén inicializados
            dataToSet.costCurrency = dataToSet.costCurrency || 'USD';
            dataToSet.saleCurrency = dataToSet.saleCurrency || 'USD';
            dataToSet.baseCurrency = dataToSet.baseCurrency || 'USD';
            dataToSet.displayCurrency = dataToSet.displayCurrency || 'USD';
        }
        return dataToSet;
    });
        setImagePreviewUrl(initialProductData.imageUrl || ''); // Establece la previsualización inicial
        setImageFile(null); // Reiniciar el archivo de imagen al cambiar de producto
        setIsUploadingMainImage(false); // Reiniciar el estado de carga de imagen principal  
        setVariantImageUploading({}); // Reiniciar el estado de carga de imágenes de variante
        setShowAdvancedOptions(false); // Reiniciar el estado de opciones avanzadas
        // Reiniciar el porcentaje de ganancia calculado
        setCalculatedProductProfitPercentage(0);
        setCalculatedProductPricePlaceholder(0);
        setCalculatedVariantProfitPercentage({});
        setCalculatedVariantPricePlaceholder({});
        // Reiniciar el estado de errores del formulario
        setFormErrors({});
        // Reiniciar el estado de sugerencias globales
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        // Reiniciar el estado de monedas
        setBaseCurrency(baseCurrency || 'USD'); // Asegurar que baseCurrency tenga un valor por defecto
        setSecondaryCurrency(secondaryCurrency || 'USD'); // Asegurar que secondaryCurrency tenga un valor por defecto
        setPrimaryCurrency(primaryCurrency || 'USD'); // Asegurar que primaryCurrency tenga un valor por defecto
        setExchangeRate(exchangeRate || 1); // Asegurar que exchangeRate tenga un valor por defecto
        // Asegurar que displayCurrency tenga un valor por defecto
        setProductData(prev => ({ ...prev, displayCurrency: prev.saleCurrency || 'USD' }));


        // Para productos existentes, si el SKU no está vacío, se considera manualmente editado
        setIsMainSkuManuallyEdited(initialProductData.sku.trim() !== '');
        // Si es un producto nuevo, el SKU se autogenerará basado en el nombre

        // Generar el SKU autogenerado al inicio, basado en el nombre inicial
        if (initialProductData.name) {
            setAutoGeneratedSku(generateSkuFromName(initialProductData.name));
        } else {
            setAutoGeneratedSku('');
        }

        // Reiniciar los estados de sugerencias globales al cambiar de producto/modo
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setFormErrors({}); // Limpiar errores al cambiar de producto
        // Lógica de porcentaje inicial para producto principal (si no tiene variantes)
    if (initialProductData.costPrice !== undefined && initialProductData.costPrice !== null && initialProductData.variants.length === 0) {
        calculateProfitAndPricePlaceholder(initialProductData.costPrice, initialProductData.price, initialProductData.costCurrency, initialProductData.saleCurrency, setCalculatedProductProfitPercentage, setCalculatedProductPricePlaceholder);
    }
    // Lógica de porcentaje inicial para variantes
    const initialVariantPercentages = {};
    const initialVariantPlaceholders = {};
    initialProductData.variants.forEach((v, idx) => {
        if (v.costPrice !== undefined && v.costPrice !== null) {
            calculateProfitAndPricePlaceholder(v.costPrice, v.price, v.costCurrency, v.saleCurrency, (percentage, pricePlaceholder) => {
                initialVariantPercentages[idx] = percentage;
                initialVariantPlaceholders[idx] = pricePlaceholder;
            });
        }
    });
    setCalculatedVariantProfitPercentage(initialVariantPercentages);
 setCalculatedVariantPricePlaceholder(initialVariantPlaceholders);
 return () => {
        // Limpiar el timeout del debounce al desmontar o cambiar de producto 
 if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
        }
    }, [initialProductData, isNewProduct, generateSkuFromName, baseCurrency, secondaryCurrency, primaryCurrency, exchangeRate, setBaseCurrency, setSecondaryCurrency, setPrimaryCurrency, setExchangeRate, displayMessage]);
    
useEffect(() => {
        // Solo se ejecuta al montar el componente o al cambiar initialProductData
        if (initialProductData) {
            setProductData(initialProductData);
            setImagePreviewUrl(initialProductData.imageUrl || '');
            setImageFile(null); // Reiniciar el archivo de imagen al cambiar de producto
            setIsUploadingMainImage(false); // Reiniciar el estado de carga de imagen principal
            setVariantImageUploading({}); // Reiniciar el estado de carga de imágenes de variante
            setShowAdvancedOptions(false); // Reiniciar el estado de opciones avanzadas
            setFormErrors({}); // Reiniciar los errores del formulario
            setGlobalProductSuggestions([]); // Limpiar sugerencias globales al cambiar de producto
            setShowGlobalSuggestions(false);
            setNoGlobalSuggestionsFound(false);
        }
        // Reiniciar el porcentaje de ganancia calculado
        setCalculatedProductProfitPercentage(0);
        setCalculatedProductPricePlaceholder(0);
        setCalculatedVariantProfitPercentage({});
        setCalculatedVariantPricePlaceholder({});
        // Reiniciar el estado de monedas
        setBaseCurrency(baseCurrency || 'USD'); // Asegurar que baseCurrency tenga un valor por defecto
        setSecondaryCurrency(secondaryCurrency || 'USD'); // Asegurar que secondaryCurrency tenga un valor por defecto  
        setPrimaryCurrency(primaryCurrency || 'USD'); // Asegurar que primaryCurrency tenga un valor por defecto
        setExchangeRate(exchangeRate || 1); // Asegurar que exchangeRate tenga un valor por defecto
        // Asegurar que displayCurrency tenga un valor por defecto
        setProductData(prev => ({ ...prev, displayCurrency: prev.saleCurrency || 'USD' }));
        // Para productos existentes, si el SKU no está vacío, se considera manualmente editado
        setIsMainSkuManuallyEdited(initialProductData.sku.trim() !== '');
        // Generar el SKU autogenerado al inicio, basado en el nombre inicial   
        if (initialProductData.name) {
            setAutoGeneratedSku(generateSkuFromName(initialProductData.name));
        } else {
            setAutoGeneratedSku('');
        }
        // Reiniciar los estados de sugerencias globales al cambiar de producto/modo
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setFormErrors({}); // Limpiar errores al cambiar de producto
    }, [initialProductData, generateSkuFromName, baseCurrency, secondaryCurrency, primaryCurrency, exchangeRate, setBaseCurrency, setSecondaryCurrency, setPrimaryCurrency, setExchangeRate, displayMessage]); // Añade displayMessage a las dependencias
    // NUEVO: Función para calcular el porcentaje de ganancia y el precio placeholder

        // Actualizar el estado con los valores calculados
        setProfitPercentage(profitPercentage);
        setPricePlaceholder(pricePlaceholder);

}, [initialProductData, generateSkuFromName, calculateProfitAndPricePlaceholder]); // Añade calculateProfitAndPricePlaceholder a las dependencias

    // Función principal para subir archivos de imagen o procesar URLs a Cloudinary
    const uploadImageToCloud = useCallback(async (fileOrUrl, isVariant = false, variantIndex = null) => {
        const formData = new FormData();
        if (fileOrUrl instanceof File) {
            formData.append('image', fileOrUrl);
        } else if (typeof fileOrUrl === 'string' && fileOrUrl.trim() !== '') {
            if (fileOrUrl.includes('res.cloudinary.com')) {
                displayMessage('La imagen ya está alojada.', 'success');
                return { success: true, url: fileOrUrl };
            }
            formData.append('imageUrl', fileOrUrl);
        } else {
            return { success: true, url: '' };
        }

        try {
            if (!isVariant) setIsUploadingMainImage(true);
            else setVariantImageUploading(prev => ({ ...prev, [variantIndex]: true }));

            const response = await axiosInstance.post('/upload', formData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });
            displayMessage('Imagen procesada y alojada exitosamente.', 'success');
            const uploadedUrl = response.data.imageUrl;

            if (isVariant && variantIndex !== null) {
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    if (updatedVariants[variantIndex]) {
                        updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: uploadedUrl };
                    }
                    return { ...prev, variants: updatedVariants };
                });
                setFormErrors(prev => ({ ...prev, [`variant-${variantIndex}-imageUrl`]: '' }));
            } else {
                setProductData(prev => ({ ...prev, imageUrl: uploadedUrl }));
                setImagePreviewUrl(uploadedUrl);
                setImageFile(null);
                setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            }
            return { success: true, url: uploadedUrl };
        } catch (err) {
            const errorMessage = err.response?.data?.message || 'Error al procesar la imagen. Por favor, inténtalo de nuevo.';
            displayMessage(errorMessage, 'error');
            if (isVariant && variantIndex !== null) {
                setFormErrors(prev => ({ ...prev, [`variant-${variantIndex}-imageUrl`]: 'Error al subir imagen.' }));
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    if (updatedVariants[variantIndex]) {
                        updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: '' };
                    }
                    return { ...prev, variants: updatedVariants };
                });
            } else {
                setFormErrors(prev => ({ ...prev, imageUrl: 'Error al subir imagen.' }));
                setProductData(prev => ({ ...prev, imageUrl: '' }));
                setImagePreviewUrl('');
                setImageFile(null);
            }
            return { success: false, error: errorMessage };
        } finally {
            if (!isVariant) setIsUploadingMainImage(false);
            else setVariantImageUploading(prev => ({ ...prev, [variantIndex]: false }));
        }
    }, [displayMessage, setFormErrors]);

    // Lógica para validar campos individuales del formulario y establecer mensajes de error
    const validateField = useCallback((name, value, currentProductState, index = null) => {
        let message = '';
        const isVariantField = index !== null;

        if (isVariantField) {
            if (name === 'name' && value.trim() === '') message = 'El nombre de la variante es obligatorio.';
            // Si el SKU de la variante está vacío y no hay autogenerado, es obligatorio.
            if (name === 'sku' && value.trim() === '' && !currentProductState.variants[index]?.autoGeneratedVariantSku) message = 'El SKU de la variante es obligatorio o se debe generar automáticamente.';
            if ((name === 'price' || name === 'costPrice' || name === 'stock') && (value === '' || value === null || value === undefined)) message = 'Campo obligatorio.';
            else if ((name === 'price' || name === 'costPrice' || name === 'stock') && isNaN(Number(value))) message = 'Debe ser un número válido.';
            else if (name === 'price' && Number(value) <= 0) message = 'El precio debe ser positivo.';
            else if ((name === 'costPrice' || name === 'stock') && Number(value) < 0) message = 'Debe ser un número no negativo.';
            if (name === 'unitOfMeasure' && value.trim() === '') message = 'La unidad de medida es obligatoria.';

            if (name === 'reorderThreshold' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
            if (currentProductState.variants[index]?.isPerishable) {
                if (name === 'optimalMaxStock' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El stock óptimo máximo debe ser un número no negativo.';
                if (name === 'shelfLifeDays' && (isNaN(Number(value)) || Number(value) < 0)) message = 'Los días de vida útil deben ser un número no negativo.';
            }
        } else {
            if (name === 'name' && value.trim() === '') message = 'El nombre es obligatorio.';
            if (currentProductState.category.trim() === '') message = 'La categoría es obligatoria.';

            // Lógica de validación para el SKU principal:
            // Es obligatorio si el campo está vacío, NO ha sido editado manualmente, Y NO hay variantes.
            // Si hay variantes, el SKU principal no es obligatorio.
            if (name === 'sku' && value.trim() === '' && !isMainSkuManuallyEdited && currentProductState.variants.length === 0) {
                message = 'El SKU es obligatorio si no hay variantes y no se ha especificado manualmente.';
            }


            if (currentProductState.variants.length === 0) {
                if ((name === 'price' || name === 'costPrice' || name === 'stock') && (value === '' || value === null || value === undefined)) message = 'Campo obligatorio.';
                else if ((name === 'price' || name === 'costPrice' || name === 'stock') && isNaN(Number(value))) message = 'Debe ser un número válido.';
                else if (name === 'price' && Number(value) <= 0) message = 'El precio debe ser positivo.';
                else if ((name === 'costPrice' || name === 'stock') && Number(value) < 0) message = 'Debe ser un número no negativo.';
                if (name === 'unitOfMeasure' && value.trim() === '') message = 'La unidad de medida es obligatoria.';
            }

            if (name === 'reorderThreshold' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
            if (currentProductState.isPerishable) {
                if (name === 'optimalMaxStock' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El stock óptimo máximo debe ser un número no negativo.';
                if (name === 'shelfLifeDays' && (isNaN(Number(value)) || Number(value) < 0)) message = 'Los días de vida útil deben ser un número no negativo.';
            }
        }
        return message;
    }, [autoGeneratedSku, isMainSkuManuallyEdited]);

    // NUEVO: Manejador general para inputs del producto principal (con toda la lógica)
    const handleProductInputChange = useCallback((e) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => ({ ...prev, [name]: inputValue }));
        displayMessage('', ''); // Limpiar mensajes generales al cambiar cualquier input
        setFormErrors(prev => ({ ...prev, [name]: '' })); // Limpiar error específico

        // Lógica específica para el tipo de producto (simple vs con variantes)
        if (name === 'variants') { // Este 'name' viene de la simulación del radio button
            if (inputValue.length === 0) { // Si se desactiva "tiene variantes" (se selecciona producto simple)
                // Asegurarse de que los campos deshabilitados ahora sean requeridos si estaban vacíos
                setFormErrors(prev => ({
                    ...prev,
                    sku: productData.sku.trim() === '' && !isMainSkuManuallyEdited ? 'El SKU es obligatorio.' : '',
                    price: productData.price === '' || productData.price === null || productData.price === undefined ? 'Campo obligatorio.' : '',
                    stock: productData.stock === '' || productData.stock === null || productData.stock === undefined ? 'Campo obligatorio.' : '',
                    costPrice: productData.costPrice === '' || productData.costPrice === null || productData.costPrice === undefined ? 'Campo obligatorio.' : '',
                    unitOfMeasure: productData.unitOfMeasure.trim() === '' ? 'La unidad de medida es obligatoria.' : '',
                    // Limpiar errores de variantes si se cambia a producto simple
                    ...Object.keys(prev).filter(key => key.startsWith('variant-')).reduce((acc, key) => ({ ...acc, [key]: '' }), {})
                }));
                // Restablecer los valores a lo que el usuario pudo haber escrito antes
                setProductData(prev => ({
                    ...prev,
                    // Opcional: podrías restablecer stock/precio/costo a valores por defecto o al último valor que tenían
                    // si el usuario alternaba entre tipos de producto. Por ahora, asumimos que los dejará como estaban si no se modifican.
                }));
            } else { // Si se activa "tiene variantes"
                // Limpiar errores de campos de producto principal que se deshabilitan
                setFormErrors(prev => ({
                    ...prev,
                    sku: '', price: '', stock: '', costPrice: '', unitOfMeasure: ''
                }));
            }
        }

        // Lógica de autogeneración de SKU y sugerencias globales (solo para el campo 'name')
        if (name === 'name') {
            const generated = generateSkuFromName(inputValue);
            setAutoGeneratedSku(generated); // Siempre genera y actualiza el SKU autogenerado

            if (isNewProduct && inputValue.trim().length >= 2) {
                // Si el usuario no ha editado el SKU manualmente, el SKU del producto se actualiza para la previsualización
                // pero el valor real del input se dejará vacío para que el placeholder sea visible.
                if (!isMainSkuManuallyEdited) {
                    setProductData(prev => ({ ...prev, sku: '' })); // Mantener el valor vacío para que el placeholder se muestre
                }


                if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
                debounceTimeoutRef.current = setTimeout(async () => {
                    try {
                        const response = await axiosInstance.get(`/globalproducts?searchTerm=${inputValue}`);
                        if (response.data && response.data.length > 0) {
                            setGlobalProductSuggestions(response.data);
                            setShowGlobalSuggestions(true);
                            setNoGlobalSuggestionsFound(false);
                        } else {
                            setGlobalProductSuggestions([]);
                            setShowGlobalSuggestions(false);
                            setNoGlobalSuggestionsFound(true);
                        }
                    } catch (error) {
                        console.error('Error fetching global product suggestions:', error);
                        setGlobalProductSuggestions([]);
                        setShowGlobalSuggestions(false);
                        setNoGlobalSuggestionsFound(false);
                    }
                }, 300);
            } else if (isNewProduct && inputValue.trim().length < 2) {
                // Si el nombre es muy corto, limpiar SKU autogenerado y sugerencias
                setAutoGeneratedSku('');
                setProductData(prev => ({ ...prev, sku: '' })); // Asegurar que el SKU en el estado esté vacío
                setGlobalProductSuggestions([]);
                setShowGlobalSuggestions(false);
                setNoGlobalSuggestionsFound(false);
            }
        }

        // Lógica para detectar si el SKU principal fue editado manualmente
        if (name === 'sku') {
            if (inputValue.trim() !== '') {
                setIsMainSkuManuallyEdited(true); // El usuario ha introducido un valor manual
            } else {
                setIsMainSkuManuallyEdited(false); // El usuario ha borrado el valor, ya no es manual
                // No necesitamos regenerar autoGeneratedSku aquí; ya se hace en el 'name' input.
                // Aquí solo nos aseguramos de que el productData.sku refleje el input vacío.
            }
        }

        // Lógica de imagen URL si el input es imageUrl
        if (name === 'imageUrl') {
            setImageFile(null); // Si el usuario escribe una URL, borramos cualquier archivo cargado
            setImagePreviewUrl(inputValue);
        }

        // Después de actualizar el estado, validar el campo
        setFormErrors(prev => ({ ...prev, [name]: validateField(name, inputValue, { ...productData, [name]: inputValue }) }));

    }, [isNewProduct, isMainSkuManuallyEdited, generateSkuFromName, debounceTimeoutRef, validateField, productData, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setFormErrors]);

    // Maneja los cambios en los campos de entrada de las variantes del producto
    const handleVariantInputChange = useCallback((index, e, fieldType = null) => { // Añade fieldType
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedVariants = [...prev.variants];
            let updatedVariant = { ...updatedVariants[index], [name]: inputValue };

            // Lógica de autogeneración de precio de venta para VARIANTE
            let currentCost = name === 'costPrice' ? Number(inputValue) : Number(updatedVariant.costPrice);
            let currentPrice = name === 'price' ? Number(inputValue) : Number(updatedVariant.price);
            let currentCostCurrency = name === 'costCurrency' ? inputValue : updatedVariant.costCurrency;
            let currentSaleCurrency = name === 'saleCurrency' ? inputValue : updatedVariant.saleCurrency;
            let profitPercentageInput = name === 'profitPercentage' ? Number(inputValue) : calculatedVariantProfitPercentage[index];
            let pricePlaceholderInput = name === 'pricePlaceholder' ? Number(inputValue) : calculatedVariantPricePlaceholder[index];

            if (name === 'costPrice' || name === 'costCurrency' || name === 'saleCurrency') {
                calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
                if (name === 'costCurrency' && updatedVariant.saleCurrency === updatedVariant.costCurrency) {
                    updatedVariant.saleCurrency = inputValue;
                }
            } else if (name === 'price') {
                calculateProfitAndPricePlaceholder(currentCost, Number(inputValue), currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
            } else if (name === 'profitPercentage') {
                if (!isNaN(currentCost) && currentCost > 0) {
                    const costInSaleCurrency = convertPrice(currentCost, currentCostCurrency, currentSaleCurrency);
                    const newCalculatedPrice = costInSaleCurrency * (1 + profitPercentageInput / 100);
                    updatedVariant.price = newCalculatedPrice.toFixed(2);
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: newCalculatedPrice.toFixed(2) }));
                }
                setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: profitPercentageInput.toFixed(2) }));
            }

            calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, profitPercentageInput, pricePlaceholderInput, (percentage, pricePlaceholder) => {
                updatedVariant.profitPercentage = percentage;
                updatedVariant.pricePlaceholder = pricePlaceholder;
            });
            updatedVariant.profitPercentage = updatedVariant.profitPercentage || 0;
            updatedVariant.pricePlaceholder = updatedVariant.pricePlaceholder || 0;

            if (name === 'name') {
                if (!updatedVariant.sku || updatedVariant.sku.trim() === '') {
                    updatedVariant.autoGeneratedVariantSku = generateSkuFromName(inputValue);
                } else {
                    updatedVariant.autoGeneratedVariantSku = '';
                }
            } else if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    updatedVariant.autoGeneratedVariantSku = '';
                } else {
                    if (updatedVariant.name && updatedVariant.name.trim() !== '') {
                        updatedVariant.autoGeneratedVariantSku = generateSkuFromName(updatedVariant.name);
                    } else {
                        updatedVariant.autoGeneratedVariantSku = '';
                    }
                }
            }

            updatedVariants[index] = updatedVariant;
            return { ...prev, variants: updatedVariants };
        });

        setFormErrors(prev => ({
            ...prev,
            [`variant-${index}-${name}`]: validateField(name, inputValue, { ...productData, variants: productData.variants.map((v, i) => i === index ? { ...v, [name]: inputValue } : v) }, index)
        }));

        displayMessage('', '');
    }, [generateSkuFromName, validateField, productData, displayMessage, setFormErrors, calculateProfitAndPricePlaceholder, convertPrice, calculatedVariantProfitPercentage, calculatedVariantPricePlaceholder]);

    // NUEVO: Manejador para el input de tipo 'file' de la imagen principal
    const handleMainImageFileChange = useCallback(async (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFile(file);
            setImagePreviewUrl(URL.createObjectURL(file));
            setProductData(prev => ({ ...prev, imageUrl: '' })); // Borrar cualquier URL si se carga un archivo
            setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            await uploadImageToCloud(file, false, null); // Sube la imagen automáticamente al seleccionar
        } else {
            setImageFile(null);
            setImagePreviewUrl(productData.imageUrl || ''); // Vuelve a la URL existente si no se selecciona nada
            setProductData(prev => ({ ...prev, imageUrl: productData.imageUrl || '' }));
        }
        displayMessage('', '');
    }, [productData.imageUrl, displayMessage, uploadImageToCloud, setFormErrors]);

    // NUEVO: Manejador para el evento onBlur del input de URL de imagen principal
    const handleMainImageUrlBlur = useCallback(async (e) => {
        const value = e.target.value;
        // Solo intenta subir si la URL no está vacía y ha cambiado, y no es una URL de Cloudinary ya
        if (value && value.trim() !== productData.imageUrl && !value.includes('res.cloudinary.com')) {
            await uploadImageToCloud(value, false, null); // Sube la URL al perder el foco
        }
    }, [productData.imageUrl, uploadImageToCloud]);


    // Maneja los cambios cuando se selecciona un archivo de imagen local para una variante
    const handleVariantImageFileChange = useCallback(async (index, e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadImageToCloud(file, true, index); // `true` para isVariant
        }
    }, [uploadImageToCloud]);


    // Añade una nueva variante al producto actual
    const handleAddVariant = useCallback(() => {
        const newVariant = {
            name: '', sku: '', price: '', costPrice: '', stock: '',
            unitOfMeasure: 'unidad', imageUrl: '', color: '', size: '', material: '',
            autoGeneratedVariantSku: '', // Se autogenerará si no se introduce
            isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
        };
        setProductData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    }, []);

    // Función para eliminar una variante por su índice.
    const handleRemoveVariant = useCallback((indexToRemove) => {
        setFormErrors(prevErrors => {
            const newErrors = { ...prevErrors };
            Object.keys(newErrors).forEach(key => {
                if (key.startsWith(`variant-${indexToRemove}-`)) {
                    delete newErrors[key];
                }
            });
            // Reajustar índices de errores si se elimina una variante intermedia
            const adjustedErrors = {};
            for (const key in newErrors) {
                const parts = key.split('-');
                if (parts[0] === 'variant' && parseInt(parts[1]) > indexToRemove) {
                    const newIndex = parseInt(parts[1]) - 1;
                    adjustedErrors[`variant-${newIndex}-${parts[2]}`] = newErrors[key];
                } else {
                    adjustedErrors[key] = newErrors[key];
                }
            }
            return adjustedErrors;
        });

        setProductData(prev => ({
            ...prev,
            variants: prev.variants.filter((_, index) => index !== indexToRemove)
        }));
    }, [setFormErrors]);

    // Función para validar todo el formulario de producto (producto principal y todas las variantes) antes del envío.
    const validateForm = useCallback((currentProductData) => {
        let errors = {};
        let isValid = true;

        // Determina el SKU final para el producto principal basado en la entrada del usuario o auto-generación
        // Ahora, si el usuario no ha editado manualmente y el campo está vacío, se usará el autoGeneratedSku
        const finalMainSku = isMainSkuManuallyEdited ? currentProductData.sku : (currentProductData.sku || autoGeneratedSku);


        // Validaciones del producto principal
        const fieldsToValidate = ['name', 'category', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'baseCurrency']; // <-- ¡AÑADIDO 'baseCurrency'
        if (currentProductData.isPerishable) {
            fieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
        }

        fieldsToValidate.forEach(fieldName => {
            let value = currentProductData[fieldName];
            // Para SKU, usar el SKU final calculado
            if (fieldName === 'sku') value = finalMainSku;

            const errorMsg = validateField(fieldName, value, currentProductData);
            if (errorMsg) {
                errors[fieldName] = errorMsg;
                isValid = false;
            }
        });

        // Validaciones de variantes
        currentProductData.variants.forEach((variant, index) => {
            const variantPrefix = `variant-${index}-`;
            const finalVariantSku = variant.sku.trim() === '' ? variant.autoGeneratedVariantSku : variant.sku;

            const variantFieldsToValidate = ['name', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold'];
            if (variant.isPerishable) {
                variantFieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
            }

            variantFieldsToValidate.forEach(fieldName => {
                let value = variant[fieldName];
                if (fieldName === 'sku') value = finalVariantSku;

                const errorMsg = validateField(fieldName, value, currentProductData, index);
                if (errorMsg) {
                    errors[`${variantPrefix}${fieldName}`] = errorMsg;
                    isValid = false;
                }
            });
        });

        setFormErrors(errors); // Actualiza el estado de los errores del formulario
        return isValid;
    }, [isNewProduct, autoGeneratedSku, validateField, setFormErrors, isMainSkuManuallyEdited]);


    const handleSubmit = useCallback(async (e) => {
        e.preventDefault();
        const isValid = validateForm(productData);
        if (!isValid) {
            displayMessage('Por favor, corrige los errores en el formulario.', 'error');
            return;
        }

        // Antes de guardar, asegurarse de que el SKU principal final sea el autogenerado si no fue editado
        const productDataToSend = { ...productData };
        if (isNewProduct && !isMainSkuManuallyEdited && productData.sku.trim() === '') {
            productDataToSend.sku = autoGeneratedSku;
        }


        await onProductSave(productDataToSend); // Llama al callback pasado por prop
    }, [onProductSave, productData, validateForm, displayMessage, isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]);


    // Maneja la selección de un producto desde las sugerencias del catálogo global.
    const handleSelectGlobalProduct = useCallback((suggestedProduct) => {
        setProductData(prev => ({ // Usar el actualizador de función para evitar dependencias circulares complejas
            ...prev, // Mantén otros campos que no se sobrescriben
            name: suggestedProduct.name,
            description: suggestedProduct.description || '',
            category: suggestedProduct.category || '',
            sku: suggestedProduct.sku || '',
            unitOfMeasure: suggestedProduct.unitOfMeasure || 'unidad',
            brand: suggestedProduct.brand || '',
            supplier: suggestedProduct.supplier || '',
            imageUrl: suggestedProduct.imageUrl || '',
            color: suggestedProduct.color || '',
            size: suggestedProduct.size || '',
            material: suggestedProduct.material || '',
            isPerishable: suggestedProduct.isPerishable || false,
            reorderThreshold: suggestedProduct.reorderThreshold || 0,
            optimalMaxStock: suggestedProduct.optimalMaxStock || 0,
            shelfLifeDays: suggestedProduct.shelfLifeDays || 0,
            baseCurrency: suggestedProduct.baseCurrency || 'USD', // <-- ¡AÑADE ESTO!
            secondaryCurrency: suggestedProduct.secondaryCurrency || 'USD', // <-- ¡AÑADE ESTO!
            primaryCurrency: suggestedProduct.primaryCurrency || 'USD', // <-- ¡AÑADE ESTO!
            exchangeRate: suggestedProduct.exchangeRate || 1, // <-- ¡AÑADE EST
            costCurrency: suggestedProduct.costCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            saleCurrency: suggestedProduct.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            displayCurrency: suggestedProduct.displayCurrency || suggestedProduct.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            variants: suggestedProduct.variants ? suggestedProduct.variants.map(v => ({
                ...v,
                autoGeneratedVariantSku: v.sku && v.sku.trim() !== '' ? '' : generateSkuFromName(v.name || ''),
                isPerishable: v.isPerishable || false,
                reorderThreshold: v.reorderThreshold || 0,
                optimalMaxStock: v.optimalMaxStock || 0,
                shelfLifeDays: v.shelfLifeDays || 0,
                costCurrency: v.costCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
                saleCurrency: v.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
                pricePlaceholder: v.pricePlaceholder || 0, // Asegurar que pricePlaceholder tenga un valor por defecto
                profitPercentage: v.profitPercentage || 0, // Asegurar que profitPercentage tenga un valor por defecto
                imageUrl: v.imageUrl || '', // Asegurar que imageUrl tenga un valor por defecto
            })) : [],
        }));
        // Actualizar el estado de las monedas basado en el producto global seleccionado
        setBaseCurrency(suggestedProduct.baseCurrency || 'USD'); // Asegurar que baseCurrency tenga un valor por defecto
        setSecondaryCurrency(suggestedProduct.secondaryCurrency || 'USD'); // Asegurar que secondaryCurrency tenga un valor por defecto
        setPrimaryCurrency(suggestedProduct.primaryCurrency || 'USD'); // Asegurar que primaryCurrency tenga un valor por defecto
        setExchangeRate(suggestedProduct.exchangeRate || 1); // Asegurar que exchangeRate tenga un valor por defecto
        setProductData(prev => ({ ...prev, displayCurrency: suggestedProduct.saleCurrency || 'USD' })); // Asegurar que displayCurrency tenga un valor por defecto
        setIsNewProduct(false); // Cambiar a modo edición
        setImageFile(null); // Limpiar archivo local
        setImagePreviewUrl(suggestedProduct.imageUrl || ''); // Establecer previsualización de la URL del producto global
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setAutoGeneratedSku(suggestedProduct.name ? generateSkuFromName(suggestedProduct.name) : ''); // Regenerar SKU autogenerado para el nuevo nombre
        setIsMainSkuManuallyEdited(suggestedProduct.sku.trim() !== ''); // Si el producto global tiene SKU, se asume manual
        setFormErrors({}); // Limpiar errores al seleccionar sugerencia
    }, [generateSkuFromName, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setIsMainSkuManuallyEdited, setFormErrors]);


    return (
        <Suspense fallback={<div>Cargando formulario...</div>}>
            <AddEditProductFormUI
                isNewProduct={isNewProduct}
                productData={productData}
                onProductDataChange={setProductData} // Pasa el setter del estado local
                onSubmit={handleSubmit}
                loading={loading}
                displayMessage={displayMessage}
                autoGeneratedSku={autoGeneratedSku}
                isMainSkuManuallyEdited={isMainSkuManuallyEdited}
                setIsMainSkuManuallyEdited={setIsMainSkuManuallyEdited}
                imageFile={imageFile}
                setImageFile={setImageFile}
                imagePreviewUrl={imagePreviewUrl}
                setImagePreviewUrl={setImagePreviewUrl}
                isUploadingMainImage={isUploadingMainImage}
                variantImageUploading={variantImageUploading}
                setVariantImageUploading={setVariantImageUploading}
                uploadImageToCloud={uploadImageToCloud}
                unitOfMeasureOptions={unitOfMeasureOptions}
                formErrors={formErrors}
                setFormErrors={setFormErrors}
                generateSkuFromName={generateSkuFromName}
                globalProductSuggestions={globalProductSuggestions}
                showGlobalSuggestions={showGlobalSuggestions}
                setShowGlobalSuggestions={setShowGlobalSuggestions}
                setNoGlobalSuggestionsFound={setNoGlobalSuggestionsFound}
                noGlobalSuggestionsFound={noGlobalSuggestionsFound}
                handleSelectGlobalProduct={handleSelectGlobalProduct}
                debounceTimeoutRef={debounceTimeoutRef}
                setShowAdvancedOptions={setShowAdvancedOptions}
                showAdvancedOptions={showAdvancedOptions}
                // Props con los handlers completos para la UI
                handleAddVariant={handleAddVariant}
                handleRemoveVariant={handleRemoveVariant}
                handleProductInputChange={handleProductInputChange} // Pasa el handler completo
                handleVariantInputChange={handleVariantInputChange}
                handleMainImageFileChange={handleMainImageFileChange} // Pasa el handler de file
                handleMainImageUrlBlur={handleMainImageUrlBlur} // Pasa el handler de onBlur de URL
                handleVariantImageFileChange={handleVariantImageFileChange}
 />
        </Suspense>
    );
}

export default AddEditProductFormLogic;