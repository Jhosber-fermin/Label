// src/components/Inventory/AddEditProductFormLogic.jsx
import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import axiosInstance from '../../api/axiosInstance';
import { useCurrency } from '../../context/CurrencyContext';
import { useDebounce } from '../../hooks/useDebounce';
import { useTranslation } from 'react-i18next';
import PropTypes from 'prop-types';
import { toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

// Importación perezosa del componente AddEditProductForm (ahora de UI)
const AddEditProductFormUI = lazy(() => import('./AddEditProductForm'));

const AddEditProductFormLogic = ({
    isNewProduct,
    initialProductData,
    onProductSave,
    loading,
    displayMessage,
    unitOfMeasureOptions,
    debounceTimeoutRef,
}) => {
    // Usa el contexto de moneda y desestructura TODO lo que necesitas de una vez
    const { exchangeRate, convertPrice, formatPrice, baseCurrency: contextBaseCurrency, primaryCurrency, secondaryCurrency } = useCurrency();

    // Estados internos para la lógica del formulario
    const [isEditing, setIsEditing] = useState(!isNewProduct);
    const [hasVariants, setHasVariants] = useState(initialProductData?.variants?.length > 0 || false);
    const [productData, setProductData] = useState(initialProductData);
    const [autoGeneratedSku, setAutoGeneratedSku] = useState('');
    const [isMainSkuManuallyEdited, setIsMainSkuManuallyEdited] = useState(false);
    const [globalProductSuggestions, setGlobalProductSuggestions] = useState([]);
    const [showGlobalSuggestions, setShowGlobalSuggestions] = useState(false);
    const [noGlobalSuggestionsFound, setNoGlobalSuggestionsFound] = useState(false);
    const [imageFile, setImageFile] = useState(null);
    const [imagePreviewUrl, setImagePreviewUrl] = useState('');
    const [isUploadingMainImage, setIsUploadingMainImage] = useState(false);
    const [variantImageUploading, setVariantImageUploading] = useState({});
    const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
    const [formErrors, setFormErrors] = useState({});

    // --- ESTADOS PARA PORCENTAJE DE GANANCIA DINÁMICO ---
    const [calculatedProductProfitPercentage, setCalculatedProductProfitPercentage] = useState(0);
    const [calculatedProductPricePlaceholder, setCalculatedProductPricePlaceholder] = useState(0);
    const [calculatedVariantProfitPercentage, setCalculatedVariantProfitPercentage] = useState({});
    const [calculatedVariantPricePlaceholder, setCalculatedVariantPricePlaceholder] = useState({});
    // --- FIN ESTADOS ---

    // Función para generar un SKU único a partir de un nombre
    const generateSkuFromName = useCallback((name) => {
        if (!name || name.trim() === '') return '';
        const cleanedName = name
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .trim()
            .toUpperCase()
            .split(/\s+/)
            .slice(0, 4)
            .join('-');
        const hash = Math.random().toString(36).substring(2, 6).toUpperCase();
        return `<span class="math-inline">\{cleanedName\.substring\(0, 15\)\}\-</span>{hash}`;
    }, []);

    // Función auxiliar para calcular porcentaje de ganancia y precio placeholder
    const calculateProfitAndPricePlaceholder = useCallback((cost, currentPrice, costCurrency, saleCurrency, setPercentage, setPricePlaceholder) => {
        if (!exchangeRate || !exchangeRate.rate || isNaN(cost) || cost <= 0) {
            setPercentage(0);
            setPricePlaceholder(0);
            return;
        }

        const defaultProfit = exchangeRate.defaultProfitPercentage || 30;
        let calculatedPrice = 0;
        let calculatedPercentage = 0;

        // Convertir costo a la moneda de venta para calcular porcentaje
        // Si el costCurrency o saleCurrency son nulos o vacíos, usar la moneda base del exchangeRate
        const effectiveCostCurrency = costCurrency || exchangeRate.fromCurrency;
        const effectiveSaleCurrency = saleCurrency || exchangeRate.fromCurrency;

        const costInSaleCurrency = convertPrice(cost, effectiveCostCurrency, effectiveSaleCurrency);

        // Si tenemos un precio de venta actual, calculamos el porcentaje
        if (!isNaN(currentPrice) && currentPrice > 0 && costInSaleCurrency > 0) {
            calculatedPercentage = ((currentPrice - costInSaleCurrency) / costInSaleCurrency) * 100;
            calculatedPrice = currentPrice; // Si ya hay un precio válido, ese es el precio a usar
        } else {
            // Si no hay precio actual o es inválido, calculamos el precio basado en el porcentaje por defecto
            calculatedPrice = costInSaleCurrency * (1 + defaultProfit / 100);
            calculatedPercentage = defaultProfit;
        }
        
        setPercentage(calculatedPercentage.toFixed(2));
        setPricePlaceholder(calculatedPrice.toFixed(2));

    }, [exchangeRate, convertPrice]); // Depende de exchangeRate y convertPrice

    // **¡AQUÍ VA LA FUNCIÓN validateField! ¡ANTES DE LOS CALLBACKS QUE LA USAN!**
    const validateField = useCallback((name, value, currentProductState, variantIndex = null) => {
        let error = '';
        const isVariantField = variantIndex !== null;

        const isProductSimple = currentProductState.variants.length === 0;

        // Helper para obtener el valor correcto si es una variante
        const getVariantValue = (fieldName) => {
            if (isVariantField) {
                return currentProductState.variants[variantIndex][fieldName];
            }
            return value; // Si no es variante, usa el value directo del campo del producto principal
        };

        const currentFieldData = isVariantField ? currentProductState.variants[variantIndex] : currentProductState;


        // Validaciones generales
        if ((name === 'name' || name === 'category' || name === 'unitOfMeasure' || name === 'price' || name === 'stock' || name === 'costPrice' || name === 'sku' || name === 'baseCurrency' || name === 'costCurrency' || name === 'saleCurrency' || name === 'displayCurrency') &&
            ((isProductSimple && !isVariantField) || isVariantField)) { // Solo aplica si es producto simple y campo principal, o si es campo de variante
            
            // Si el campo es SKU y el producto es nuevo y el SKU no ha sido editado manualmente
            if (name === 'sku' && isNewProduct && !isMainSkuManuallyEdited && (value === '' || value === undefined || value === null)) {
                error = ''; // No hay error, se autogenera
            } else if (name === 'sku' && value.trim() === '') {
                error = 'El SKU es obligatorio.';
            } else if (name === 'name' && value.trim() === '') {
                error = 'El nombre es obligatorio.';
            } else if (name === 'category' && value.trim() === '') {
                error = 'La categoría es obligatoria.';
            } else if (name === 'unitOfMeasure' && value.trim() === '') {
                error = 'La unidad de medida es obligatoria.';
            } else if (name === 'price' && (value === '' || isNaN(Number(value)) || Number(value) <= 0)) {
                error = 'El precio de venta debe ser un número positivo.';
            } else if (name === 'costPrice' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El costo unitario debe ser un número no negativo.';
            } else if (name === 'stock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock debe ser un número no negativo.';
            } else if ((name === 'baseCurrency' || name === 'costCurrency' || name === 'saleCurrency' || name === 'displayCurrency') && value.trim() === '') {
                 error = 'La moneda es obligatoria.';
            }
        }
        
        // Validaciones específicas para perecederos
        if (currentFieldData.isPerishable) {
            if (name === 'optimalMaxStock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock óptimo máximo debe ser un número no negativo.';
            }
            if (name === 'shelfLifeDays' && (value === '' || isNaN(Number(value)) || Number(value) <= 0)) {
                error = 'La vida útil debe ser un número positivo de días.';
            }
        }

        // Validación del umbral de reaprovisionamiento
        if (name === 'reorderThreshold' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
            error = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
        }

        // Validación para la URL de la imagen principal
        if (name === 'imageUrl' && value.trim() !== '' && !/^https?:\/\/.+\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(value)) {
            error = 'La URL de la imagen no es válida.';
        }

        // Validación de unicidad de SKU (siempre al final para no interferir con otras validaciones)
        // Solo para productos existentes o si el SKU principal fue editado manualmente
        if (name === 'sku' && value.trim() !== '' && (isProductSimple || isVariantField)) { // Aplica a SKU principal o SKU de variante
            // Esta lógica de unicidad se maneja mejor en el backend antes de guardar
            // Pero si quieres una validación frontal en tiempo real, deberías debouncarla y hacer una llamada a la API
            // Por ahora, solo es una validación básica de formato.
        }

        return error;
    }, [isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]); // <-- Dependencias para useCallback

    // Sincroniza el estado interno con las props iniciales (para edición o nuevo producto)
    useEffect(() => {
        setProductData(prevData => {
            const dataToSet = { ...initialProductData };
            
            // Asegurar que `initialProductData` esté completo para evitar `undefined` o `null`
            Object.keys(defaultNewProductState).forEach(key => {
                if (dataToSet[key] === undefined) {
                    dataToSet[key] = defaultNewProductState[key];
                }
            });

            // Inicializar las nuevas monedas si es un producto nuevo o no las tiene
            dataToSet.costCurrency = dataToSet.costCurrency || 'USD';
            dataToSet.saleCurrency = dataToSet.saleCurrency || 'USD';
            dataToSet.baseCurrency = dataToSet.baseCurrency || contextBaseCurrency || 'USD';
            dataToSet.displayCurrency = dataToSet.displayCurrency || dataToSet.saleCurrency || 'USD';

            // Asegurar que las variantes también tengan los nuevos campos de moneda inicializados
            dataToSet.variants = dataToSet.variants ? dataToSet.variants.map(v => ({
                ...v,
                costCurrency: v.costCurrency || 'USD',
                saleCurrency: v.saleCurrency || 'USD',
            })) : [];
            
            // Si es un producto con variantes, ciertos campos del padre deben ser informativos
            if (dataToSet.variants.length > 0) {
                dataToSet.stock = 0;
                dataToSet.price = 0;
                dataToSet.costPrice = 0;
            }

            return dataToSet;
        });

        // Sincronizar estados adicionales y generar SKU
        setImagePreviewUrl(initialProductData.imageUrl || '');
        setImageFile(null);
        setIsUploadingMainImage(false);
        setVariantImageUploading({});
        setShowAdvancedOptions(false);
        setFormErrors({});
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);

        setIsMainSkuManuallyEdited(initialProductData.sku?.trim() !== '');
        setAutoGeneratedSku(initialProductData.name ? generateSkuFromName(initialProductData.name) : '');

        // Calcular porcentajes y placeholders al cargar el producto para edición
        if (initialProductData.costPrice !== undefined && initialProductData.costPrice !== null && initialProductData.variants?.length === 0) {
            calculateProfitAndPricePlaceholder(
                Number(initialProductData.costPrice),
                Number(initialProductData.price),
                initialProductData.costCurrency || 'USD',
                initialProductData.saleCurrency || 'USD',
                setCalculatedProductProfitPercentage,
                setCalculatedProductPricePlaceholder
            );
        }
        const initialVariantPercentages = {};
        const initialVariantPlaceholders = {};
        initialProductData.variants?.forEach((v, idx) => {
            if (v.costPrice !== undefined && v.costPrice !== null) {
                calculateProfitAndPricePlaceholder(
                    Number(v.costPrice),
                    Number(v.price),
                    v.costCurrency || 'USD',
                    v.saleCurrency || 'USD',
                    (percentage, pricePlaceholder) => {
                        initialVariantPercentages[idx] = percentage;
                        initialVariantPlaceholders[idx] = pricePlaceholder;
                    }
                );
            }
        });
        setCalculatedVariantProfitPercentage(initialVariantPercentages);
        setCalculatedVariantPricePlaceholder(initialVariantPlaceholders);

        return () => {
            if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
        };
    }, [initialProductData, isNewProduct, generateSkuFromName, contextBaseCurrency, calculateProfitAndPricePlaceholder, debounceTimeoutRef]);


    // Manejador general para inputs del producto principal (con toda la lógica)
    const handleProductInputChange = useCallback((e, fieldType = null) => {
        const { name, value, type, checked } = e.target;
        let inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedData = { ...prev, [name]: inputValue };

            // Lógica de autogeneración de precio de venta basado en costo y porcentaje de ganancia
            if (prev.variants.length === 0) { // Solo para productos simples
                let currentCost = name === 'costPrice' ? Number(inputValue) : Number(prev.costPrice);
                let currentPrice = name === 'price' ? Number(inputValue) : Number(prev.price);
                let currentCostCurrency = name === 'costCurrency' ? inputValue : prev.costCurrency;
                let currentSaleCurrency = name === 'saleCurrency' ? inputValue : prev.saleCurrency;
                let profitPercentageInput = name === 'profitPercentage' ? Number(inputValue) : calculatedProductProfitPercentage;

                if (name === 'costPrice' || name === 'costCurrency' || name === 'saleCurrency') {
                    calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, setCalculatedProductProfitPercentage, setCalculatedProductPricePlaceholder);
                    if (name === 'costCurrency' && (prev.saleCurrency === prev.costCurrency || !prev.saleCurrency)) { // Si cambias costCurrency y saleCurrency era igual o no definido
                        updatedData.saleCurrency = inputValue; // Actualiza saleCurrency también
                    }
                    if (name === 'costCurrency' && (prev.displayCurrency === prev.saleCurrency || !prev.displayCurrency)) { // Si cambias costCurrency y displayCurrency era igual o no definido
                        updatedData.displayCurrency = inputValue; // Actualiza displayCurrency también
                    }
                } else if (name === 'price') {
                    calculateProfitAndPricePlaceholder(currentCost, Number(inputValue), currentCostCurrency, currentSaleCurrency, setCalculatedProductProfitPercentage, setCalculatedProductPricePlaceholder);
                } else if (name === 'profitPercentage') {
                    if (!isNaN(currentCost) && currentCost > 0) {
                        const costInSaleCurrency = convertPrice(currentCost, currentCostCurrency, currentSaleCurrency);
                        const newCalculatedPrice = costInSaleCurrency * (1 + profitPercentageInput / 100);
                        updatedData.price = newCalculatedPrice.toFixed(2);
                        setCalculatedProductPricePlaceholder(newCalculatedPrice.toFixed(2));
                    }
                    setCalculatedProductProfitPercentage(profitPercentageInput.toFixed(2));
                }
            }

            // Lógica para detectar si el SKU principal fue editado manualmente
            if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    setIsMainSkuManuallyEdited(true);
                } else {
                    setIsMainSkuManuallyEdited(false);
                }
            }
            
            // Lógica de imagen URL si el input es imageUrl
            if (name === 'imageUrl') {
                setImageFile(null);
                setImagePreviewUrl(inputValue);
            }

            return updatedData;
        });
        displayMessage('', '');
        setFormErrors(prev => ({ ...prev, [name]: '' }));
        setFormErrors(prev => ({ ...prev, [name]: validateField(name, inputValue, { ...productData, [name]: inputValue }, null) })); // Pasa null para variantIndex para producto principal

    }, [isNewProduct, isMainSkuManuallyEdited, generateSkuFromName, debounceTimeoutRef, validateField, productData, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setFormErrors, calculateProfitAndPricePlaceholder, convertPrice, calculatedProductProfitPercentage]);


    // Maneja los cambios en los campos de entrada de las variantes del producto
    const handleVariantInputChange = useCallback((index, e, fieldType = null) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedVariants = [...prev.variants];
            let updatedVariant = { ...updatedVariants[index], [name]: inputValue };

            // Lógica de autogeneración de precio de venta para VARIANTE
            let currentCost = name === 'costPrice' ? Number(inputValue) : Number(updatedVariant.costPrice);
            let currentPrice = name === 'price' ? Number(inputValue) : Number(updatedVariant.price);
            let currentCostCurrency = name === 'costCurrency' ? inputValue : updatedVariant.costCurrency;
            let currentSaleCurrency = name === 'saleCurrency' ? inputValue : updatedVariant.saleCurrency;
            let profitPercentageInput = name === 'profitPercentage' ? Number(inputValue) : calculatedVariantProfitPercentage[index];

            if (name === 'costPrice' || name === 'costCurrency' || name === 'saleCurrency') {
                calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
                if (name === 'costCurrency' && (updatedVariant.saleCurrency === updatedVariant.costCurrency || !updatedVariant.saleCurrency)) {
                    updatedVariant.saleCurrency = inputValue;
                }
            } else if (name === 'price') {
                calculateProfitAndPricePlaceholder(currentCost, Number(inputValue), currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
            } else if (name === 'profitPercentage') {
                if (!isNaN(currentCost) && currentCost > 0) {
                    const costInSaleCurrency = convertPrice(currentCost, currentCostCurrency, currentSaleCurrency);
                    const newCalculatedPrice = costInSaleCurrency * (1 + profitPercentageInput / 100);
                    updatedVariant.price = newCalculatedPrice.toFixed(2);
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: newCalculatedPrice.toFixed(2) }));
                }
                setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: profitPercentageInput.toFixed(2) }));
            }

            // Lógica de generación de SKU para variantes (sin cambios aquí)
            if (name === 'name') {
                if (!updatedVariant.sku || updatedVariant.sku.trim() === '') {
                    updatedVariant.autoGeneratedVariantSku = generateSkuFromName(inputValue);
                } else {
                    updatedVariant.autoGeneratedVariantSku = '';
                }
            } else if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    updatedVariant.autoGeneratedVariantSku = '';
                } else {
                    if (updatedVariant.name && updatedVariant.name.trim() !== '') {
                        updatedVariant.autoGeneratedVariantSku = generateSkuFromName(updatedVariant.name);
                    } else {
                        updatedVariant.autoGeneratedVariantSku = '';
                    }
                }
            }

            updatedVariants[index] = updatedVariant;
            return { ...prev, variants: updatedVariants };
        });

        setFormErrors(prev => ({
            ...prev,
            [`variant-<span class="math-inline">\{index\}\-</span>{name}`]: validateField(name, inputValue, { ...productData, variants: productData.variants.map((v, i) => i === index ? { ...v, [name]: inputValue } : v) }, index)
        }));

        displayMessage('', '');
    }, [generateSkuFromName, validateField, productData, displayMessage, setFormErrors, calculateProfitAndPricePlaceholder, convertPrice, calculatedVariantProfitPercentage, calculatedVariantPricePlaceholder]);

    // NUEVO: Manejador para el input de tipo 'file' de la imagen principal
    const handleMainImageFileChange = useCallback(async (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFile(file);
            setImagePreviewUrl(URL.createObjectURL(file));
            setProductData(prev => ({ ...prev, imageUrl: '' })); // Borrar cualquier URL si se carga un archivo
            setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            await uploadImageToCloud(file, false, null); // Sube la imagen automáticamente al seleccionar
        } else {
            setImageFile(null);
            setImagePreviewUrl(productData.imageUrl || ''); // Vuelve a la URL existente si no se selecciona nada
            setProductData(prev => ({ ...prev, imageUrl: productData.imageUrl || '' }));
        }
        displayMessage('', '');
    }, [productData.imageUrl, displayMessage, uploadImageToCloud, setFormErrors]);

    // NUEVO: Manejador para el evento onBlur del input de URL de imagen principal
    const handleMainImageUrlBlur = useCallback(async (e) => {
        const value = e.target.value;
        // Solo intenta subir si la URL no está vacía y ha cambiado, y no es una URL de Cloudinary ya
        if (value && value.trim() !== productData.imageUrl && !value.includes('res.cloudinary.com')) {
            await uploadImageToCloud(value, false, null); // Sube la URL al perder el foco
        }
    }, [productData.imageUrl, uploadImageToCloud]);


    // Maneja los cambios cuando se selecciona un archivo de imagen local para una variante
    const handleVariantImageFileChange = useCallback(async (index, e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadImageToCloud(file, true, index); // `true` para isVariant
        }
    }, [uploadImageToCloud]);


    // Añade una nueva variante al producto actual
    const handleAddVariant = useCallback(() => {
        const newVariant = {
            name: '', sku: '', price: '', costPrice: '', stock: '',
            unitOfMeasure: 'unidad', imageUrl: '', color: '', size: '', material: '',
            autoGeneratedVariantSku: '', // Se autogenerará si no se introduce
            isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
        };
        setProductData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    }, []);

    // Función para eliminar una variante por su índice.
    const handleRemoveVariant = useCallback((indexToRemove) => {
        setFormErrors(prevErrors => {
            const newErrors = { ...prevErrors };
            Object.keys(newErrors).forEach(key => {
                if (key.startsWith(`variant-${indexToRemove}-`)) {
                    delete newErrors[key];
                }
            });
            // Reajustar índices de errores si se elimina una variante intermedia
            const adjustedErrors = {};
            for (const key in newErrors) {
                const parts = key.split('-');
                if (parts[0] === 'variant' && parseInt(parts[1]) > indexToRemove) {
                    const newIndex = parseInt(parts[1]) - 1;
                    adjustedErrors[`variant-${newIndex}-${parts[2]}`] = newErrors[key];
                } else {
                    adjustedErrors[key] = newErrors[key];
                }
            }
            return adjustedErrors;
        });

        setProductData(prev => ({
            ...prev,
            variants: prev.variants.filter((_, index) => index !== indexToRemove)
        }));
    }, [setFormErrors]);

    // Función para validar todo el formulario de producto (producto principal y todas las variantes) antes del envío.
    const validateForm = useCallback((currentProductData) => {
        let errors = {};
        let isValid = true;

        // Determina el SKU final para el producto principal basado en la entrada del usuario o auto-generación
        // Ahora, si el usuario no ha editado manualmente y el campo está vacío, se usará el autoGeneratedSku
        const finalMainSku = isMainSkuManuallyEdited ? currentProductData.sku : (currentProductData.sku || autoGeneratedSku);


        // Validaciones del producto principal
        const fieldsToValidate = ['name', 'category', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'baseCurrency']; // <-- ¡AÑADIDO 'baseCurrency'
        if (currentProductData.isPerishable) {
            fieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
        }

        fieldsToValidate.forEach(fieldName => {
            let value = currentProductData[fieldName];
            // Para SKU, usar el SKU final calculado
            if (fieldName === 'sku') value = finalMainSku;

            const errorMsg = validateField(fieldName, value, currentProductData);
            if (errorMsg) {
                errors[fieldName] = errorMsg;
                isValid = false;
            }
        });

        // Validaciones de variantes
        currentProductData.variants.forEach((variant, index) => {
            const variantPrefix = `variant-${index}-`;
            const finalVariantSku = variant.sku.trim() === '' ? variant.autoGeneratedVariantSku : variant.sku;

            const variantFieldsToValidate = ['name', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold'];
            if (variant.isPerishable) {
                variantFieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
            }

            variantFieldsToValidate.forEach(fieldName => {
                let value = variant[fieldName];
                if (fieldName === 'sku') value = finalVariantSku;

                const errorMsg = validateField(fieldName, value, currentProductData, index);
                if (errorMsg) {
                    errors[`${variantPrefix}${fieldName}`] = errorMsg;
                    isValid = false;
                }
            });
        });

        setFormErrors(errors); // Actualiza el estado de los errores del formulario
        return isValid;
    }, [isNewProduct, autoGeneratedSku, validateField, setFormErrors, isMainSkuManuallyEdited]);


    const handleSubmit = useCallback(async (e) => {
        e.preventDefault();
        const isValid = validateForm(productData);
        if (!isValid) {
            displayMessage('Por favor, corrige los errores en el formulario.', 'error');
            return;
        }

        // Antes de guardar, asegurarse de que el SKU principal final sea el autogenerado si no fue editado
        const productDataToSend = { ...productData };
        if (isNewProduct && !isMainSkuManuallyEdited && productData.sku.trim() === '') {
            productDataToSend.sku = autoGeneratedSku;
        }


        await onProductSave(productDataToSend); // Llama al callback pasado por prop
    }, [onProductSave, productData, validateForm, displayMessage, isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]);


    // Maneja la selección de un producto desde las sugerencias del catálogo global.
    const handleSelectGlobalProduct = useCallback((suggestedProduct) => {
        setProductData(prev => ({ // Usar el actualizador de función para evitar dependencias circulares complejas
            ...prev, // Mantén otros campos que no se sobrescriben
            name: suggestedProduct.name,
            description: suggestedProduct.description || '',
            category: suggestedProduct.category || '',
            sku: suggestedProduct.sku || '',
            unitOfMeasure: suggestedProduct.unitOfMeasure || 'unidad',
            brand: suggestedProduct.brand || '',
            supplier: suggestedProduct.supplier || '',
            imageUrl: suggestedProduct.imageUrl || '',
            color: suggestedProduct.color || '',
            size: suggestedProduct.size || '',
            material: suggestedProduct.material || '',
            isPerishable: suggestedProduct.isPerishable || false,
            reorderThreshold: suggestedProduct.reorderThreshold || 0,
            optimalMaxStock: suggestedProduct.optimalMaxStock || 0,
            shelfLifeDays: suggestedProduct.shelfLifeDays || 0,
            baseCurrency: suggestedProduct.baseCurrency || 'USD', // <-- ¡AÑADE ESTO!
            secondaryCurrency: suggestedProduct.secondaryCurrency || 'USD', // <-- ¡AÑADE ESTO!
            primaryCurrency: suggestedProduct.primaryCurrency || 'USD', // <-- ¡AÑADE ESTO!
            exchangeRate: suggestedProduct.exchangeRate || 1, // <-- ¡AÑADE EST
            costCurrency: suggestedProduct.costCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            saleCurrency: suggestedProduct.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            displayCurrency: suggestedProduct.displayCurrency || suggestedProduct.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
            variants: suggestedProduct.variants ? suggestedProduct.variants.map(v => ({
                ...v,
                autoGeneratedVariantSku: v.sku && v.sku.trim() !== '' ? '' : generateSkuFromName(v.name || ''),
                isPerishable: v.isPerishable || false,
                reorderThreshold: v.reorderThreshold || 0,
                optimalMaxStock: v.optimalMaxStock || 0,
                shelfLifeDays: v.shelfLifeDays || 0,
                costCurrency: v.costCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
                saleCurrency: v.saleCurrency || 'USD', // <-- ¡NUEVA LÍNEA!
                pricePlaceholder: v.pricePlaceholder || 0, // Asegurar que pricePlaceholder tenga un valor por defecto
                profitPercentage: v.profitPercentage || 0, // Asegurar que profitPercentage tenga un valor por defecto
                imageUrl: v.imageUrl || '', // Asegurar que imageUrl tenga un valor por defecto
            })) : [],
        }));
        // Actualizar el estado de las monedas basado en el producto global seleccionado
        setBaseCurrency(suggestedProduct.baseCurrency || 'USD'); // Asegurar que baseCurrency tenga un valor por defecto
        setSecondaryCurrency(suggestedProduct.secondaryCurrency || 'USD'); // Asegurar que secondaryCurrency tenga un valor por defecto
        setPrimaryCurrency(suggestedProduct.primaryCurrency || 'USD'); // Asegurar que primaryCurrency tenga un valor por defecto
        setExchangeRate(suggestedProduct.exchangeRate || 1); // Asegurar que exchangeRate tenga un valor por defecto
        setProductData(prev => ({ ...prev, displayCurrency: suggestedProduct.saleCurrency || 'USD' })); // Asegurar que displayCurrency tenga un valor por defecto
        setIsNewProduct(false); // Cambiar a modo edición
        setImageFile(null); // Limpiar archivo local
        setImagePreviewUrl(suggestedProduct.imageUrl || ''); // Establecer previsualización de la URL del producto global
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setAutoGeneratedSku(suggestedProduct.name ? generateSkuFromName(suggestedProduct.name) : ''); // Regenerar SKU autogenerado para el nuevo nombre
        setIsMainSkuManuallyEdited(suggestedProduct.sku.trim() !== ''); // Si el producto global tiene SKU, se asume manual
        setFormErrors({}); // Limpiar errores al seleccionar sugerencia
    }, [generateSkuFromName, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setIsMainSkuManuallyEdited, setFormErrors]);


     return (
        <Suspense fallback={<div>Cargando formulario...</div>}>
            <AddEditProductFormUI
                isNewProduct={isNewProduct}
                productData={productData}
                onProductDataChange={setProductData}
                onSubmit={handleSubmit}
                loading={loading}
                displayMessage={displayMessage}
                autoGeneratedSku={autoGeneratedSku}
                isMainSkuManuallyEdited={isMainSkuManuallyEdited}
                setIsMainSkuManuallyEdited={setIsMainSkuManuallyEdited}
                imageFile={imageFile}
                setImageFile={setImageFile}
                imagePreviewUrl={imagePreviewUrl}
                setImagePreviewUrl={setImagePreviewUrl}
                isUploadingMainImage={isUploadingMainImage}
                variantImageUploading={variantImageUploading}
                setVariantImageUploading={setVariantImageUploading}
                uploadImageToCloud={uploadImageToCloud}
                unitOfMeasureOptions={unitOfMeasureOptions}
                formErrors={formErrors}
                setFormErrors={setFormErrors}
                generateSkuFromName={generateSkuFromName}
                globalProductSuggestions={globalProductSuggestions}
                showGlobalSuggestions={showGlobalSuggestions}
                setShowGlobalSuggestions={setShowGlobalSuggestions}
                setNoGlobalSuggestionsFound={setNoGlobalSuggestionsFound}
                noGlobalSuggestionsFound={noGlobalSuggestionsFound}
                handleSelectGlobalProduct={handleSelectGlobalProduct}
                debounceTimeoutRef={debounceTimeoutRef}
                setShowAdvancedOptions={setShowAdvancedOptions}
                showAdvancedOptions={showAdvancedOptions}
                // Props con los handlers completos para la UI
                handleAddVariant={handleAddVariant}
                handleRemoveVariant={handleRemoveVariant}
                handleProductInputChange={handleProductInputChange}
                handleVariantInputChange={handleVariantInputChange}
                handleMainImageFileChange={handleMainImageFileChange}
                handleMainImageUrlBlur={handleMainImageUrlBlur}
                handleVariantImageFileChange={handleVariantImageFileChange}
                // NUEVAS PROPS PARA EL PORCENTAJE DINÁMICO
                calculatedProductProfitPercentage={calculatedProductProfitPercentage}
                calculatedProductPricePlaceholder={calculatedProductPricePlaceholder}
                calculatedVariantProfitPercentage={calculatedVariantProfitPercentage}
                calculatedVariantPricePlaceholder={calculatedVariantPricePlaceholder}
            />
        </Suspense>
    );
};

export default AddEditProductFormLogic;