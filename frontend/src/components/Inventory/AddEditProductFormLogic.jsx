// src/components/Inventory/AddEditProductFormLogic.jsx
import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import axiosInstance from '../../api/axiosInstance';

// Importación perezosa del componente AddEditProductForm (ahora de UI)
const AddEditProductFormUI = lazy(() => import('./AddEditProductForm'));

const AddEditProductFormLogic = ({
    isNewProduct,
    initialProductData, // Producto inicial para edición o vacío para nuevo
    onProductSave, // Callback para InventoryPage (handleAddProduct o handleUpdateProduct)
    loading,
    displayMessage,
    unitOfMeasureOptions,
    debounceTimeoutRef, // Pasado desde InventoryPage para el debounce
}) => {
    // Estados internos para la lógica del formulario
    const [productData, setProductData] = useState(initialProductData);
    const [autoGeneratedSku, setAutoGeneratedSku] = useState(''); // Se usará para el placeholder
    const [isMainSkuManuallyEdited, setIsMainSkuManuallyEdited] = useState(false); // Indica si el usuario ha editado el SKU manualmente
    const [globalProductSuggestions, setGlobalProductSuggestions] = useState([]);
    const [showGlobalSuggestions, setShowGlobalSuggestions] = useState(false);
    const [noGlobalSuggestionsFound, setNoGlobalSuggestionsFound] = useState(false);
    const [imageFile, setImageFile] = useState(null);
    const [imagePreviewUrl, setImagePreviewUrl] = useState('');
    const [isUploadingMainImage, setIsUploadingMainImage] = useState(false);
    const [variantImageUploading, setVariantImageUploading] = useState({});
    const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
    const [formErrors, setFormErrors] = useState({});

    // Función para generar un SKU único a partir de un nombre
    // ESTA FUNCIÓN HA SIDO MOVIDA AQUÍ ARRIBA PARA EVITAR EL "ReferenceError"
    const generateSkuFromName = useCallback((name) => {
        if (!name || name.trim() === '') return '';
        const cleanedName = name
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .trim()
            .toUpperCase()
            .split(/\s+/)
            .slice(0, 4)
            .join('-');
        const hash = Math.random().toString(36).substring(2, 6).toUpperCase();
        return `${cleanedName.substring(0, 15)}-${hash}`;
    }, []);


    // Sincroniza el estado interno con las props iniciales (para edición)
useEffect(() => {
    setProductData(prevData => {
        const dataToSet = { ...initialProductData };
        // Si es un producto nuevo o un producto existente sin variantes, los campos normales se usan
        // Si es un producto con variantes, ciertos campos del padre deben ser informativos
        if (dataToSet.variants && dataToSet.variants.length > 0) {
            // Forzamos stock, precio, costo, unidad y SKU del padre a valores informativos/neutros
            // ya que serán derivados de las variantes en el pre-save hook del backend
            dataToSet.stock = 0; // Se recalculará en el backend
            dataToSet.price = 0; // Se derivará del primer precio de variante en el backend
            dataToSet.costPrice = 0; // Se derivará del primer costo de variante en el backend
            // SKU y unitOfMeasure no los tocaremos aquí, ya que pueden ser relevantes para el producto padre
            // aunque estén deshabilitados para edición si tiene variantes.
        }
        return dataToSet;
    });
        setImagePreviewUrl(initialProductData.imageUrl || ''); // Establece la previsualización inicial

        // Para productos existentes, si el SKU no está vacío, se considera manualmente editado
        setIsMainSkuManuallyEdited(initialProductData.sku.trim() !== '');

        // Generar el SKU autogenerado al inicio, basado en el nombre inicial
        if (initialProductData.name) {
            setAutoGeneratedSku(generateSkuFromName(initialProductData.name));
        } else {
            setAutoGeneratedSku('');
        }

        // Reiniciar los estados de sugerencias globales al cambiar de producto/modo
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setFormErrors({}); // Limpiar errores al cambiar de producto
    }, [initialProductData, generateSkuFromName]);

    // Función principal para subir archivos de imagen o procesar URLs a Cloudinary
    const uploadImageToCloud = useCallback(async (fileOrUrl, isVariant = false, variantIndex = null) => {
        const formData = new FormData();
        if (fileOrUrl instanceof File) {
            formData.append('image', fileOrUrl);
        } else if (typeof fileOrUrl === 'string' && fileOrUrl.trim() !== '') {
            if (fileOrUrl.includes('res.cloudinary.com')) {
                displayMessage('La imagen ya está alojada.', 'success');
                return { success: true, url: fileOrUrl };
            }
            formData.append('imageUrl', fileOrUrl);
        } else {
            return { success: true, url: '' };
        }

        try {
            if (!isVariant) setIsUploadingMainImage(true);
            else setVariantImageUploading(prev => ({ ...prev, [variantIndex]: true }));

            const response = await axiosInstance.post('/upload', formData, {
                headers: { 'Content-Type': 'multipart/form-data' }
            });
            displayMessage('Imagen procesada y alojada exitosamente.', 'success');
            const uploadedUrl = response.data.imageUrl;

            if (isVariant && variantIndex !== null) {
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    if (updatedVariants[variantIndex]) {
                        updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: uploadedUrl };
                    }
                    return { ...prev, variants: updatedVariants };
                });
                setFormErrors(prev => ({ ...prev, [`variant-${variantIndex}-imageUrl`]: '' }));
            } else {
                setProductData(prev => ({ ...prev, imageUrl: uploadedUrl }));
                setImagePreviewUrl(uploadedUrl);
                setImageFile(null);
                setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            }
            return { success: true, url: uploadedUrl };
        } catch (err) {
            const errorMessage = err.response?.data?.message || 'Error al procesar la imagen. Por favor, inténtalo de nuevo.';
            displayMessage(errorMessage, 'error');
            if (isVariant && variantIndex !== null) {
                setFormErrors(prev => ({ ...prev, [`variant-${variantIndex}-imageUrl`]: 'Error al subir imagen.' }));
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    if (updatedVariants[variantIndex]) {
                        updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: '' };
                    }
                    return { ...prev, variants: updatedVariants };
                });
            } else {
                setFormErrors(prev => ({ ...prev, imageUrl: 'Error al subir imagen.' }));
                setProductData(prev => ({ ...prev, imageUrl: '' }));
                setImagePreviewUrl('');
                setImageFile(null);
            }
            return { success: false, error: errorMessage };
        } finally {
            if (!isVariant) setIsUploadingMainImage(false);
            else setVariantImageUploading(prev => ({ ...prev, [variantIndex]: false }));
        }
    }, [displayMessage, setFormErrors]);

    // Lógica para validar campos individuales del formulario y establecer mensajes de error
    const validateField = useCallback((name, value, currentProductState, index = null) => {
        let message = '';
        const isVariantField = index !== null;

        if (isVariantField) {
            if (name === 'name' && value.trim() === '') message = 'El nombre de la variante es obligatorio.';
            // Si el SKU de la variante está vacío y no hay autogenerado, es obligatorio.
            if (name === 'sku' && value.trim() === '' && !currentProductState.variants[index]?.autoGeneratedVariantSku) message = 'El SKU de la variante es obligatorio o se debe generar automáticamente.';
            if ((name === 'price' || name === 'costPrice' || name === 'stock') && (value === '' || value === null || value === undefined)) message = 'Campo obligatorio.';
            else if ((name === 'price' || name === 'costPrice' || name === 'stock') && isNaN(Number(value))) message = 'Debe ser un número válido.';
            else if (name === 'price' && Number(value) <= 0) message = 'El precio debe ser positivo.';
            else if ((name === 'costPrice' || name === 'stock') && Number(value) < 0) message = 'Debe ser un número no negativo.';
            if (name === 'unitOfMeasure' && value.trim() === '') message = 'La unidad de medida es obligatoria.';

            if (name === 'reorderThreshold' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
            if (currentProductState.variants[index]?.isPerishable) {
                if (name === 'optimalMaxStock' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El stock óptimo máximo debe ser un número no negativo.';
                if (name === 'shelfLifeDays' && (isNaN(Number(value)) || Number(value) < 0)) message = 'Los días de vida útil deben ser un número no negativo.';
            }
        } else {
            if (name === 'name' && value.trim() === '') message = 'El nombre es obligatorio.';
            if (currentProductState.category.trim() === '') message = 'La categoría es obligatoria.';

            // Lógica de validación para el SKU principal:
            // Es obligatorio si el campo está vacío, NO ha sido editado manualmente, Y NO hay variantes.
            // Si hay variantes, el SKU principal no es obligatorio.
            if (name === 'sku' && value.trim() === '' && !isMainSkuManuallyEdited && currentProductState.variants.length === 0) {
                message = 'El SKU es obligatorio si no hay variantes y no se ha especificado manualmente.';
            }


            if (currentProductState.variants.length === 0) {
                if ((name === 'price' || name === 'costPrice' || name === 'stock') && (value === '' || value === null || value === undefined)) message = 'Campo obligatorio.';
                else if ((name === 'price' || name === 'costPrice' || name === 'stock') && isNaN(Number(value))) message = 'Debe ser un número válido.';
                else if (name === 'price' && Number(value) <= 0) message = 'El precio debe ser positivo.';
                else if ((name === 'costPrice' || name === 'stock') && Number(value) < 0) message = 'Debe ser un número no negativo.';
                if (name === 'unitOfMeasure' && value.trim() === '') message = 'La unidad de medida es obligatoria.';
            }

            if (name === 'reorderThreshold' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
            if (currentProductState.isPerishable) {
                if (name === 'optimalMaxStock' && (isNaN(Number(value)) || Number(value) < 0)) message = 'El stock óptimo máximo debe ser un número no negativo.';
                if (name === 'shelfLifeDays' && (isNaN(Number(value)) || Number(value) < 0)) message = 'Los días de vida útil deben ser un número no negativo.';
            }
        }
        return message;
    }, [autoGeneratedSku, isMainSkuManuallyEdited]);

    // NUEVO: Manejador general para inputs del producto principal (con toda la lógica)
    const handleProductInputChange = useCallback((e) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => ({ ...prev, [name]: inputValue }));
        displayMessage('', ''); // Limpiar mensajes generales al cambiar cualquier input
        setFormErrors(prev => ({ ...prev, [name]: '' })); // Limpiar error específico

        // Lógica específica para el tipo de producto (simple vs con variantes)
        if (name === 'variants') { // Este 'name' viene de la simulación del radio button
            if (inputValue.length === 0) { // Si se desactiva "tiene variantes" (se selecciona producto simple)
                // Asegurarse de que los campos deshabilitados ahora sean requeridos si estaban vacíos
                setFormErrors(prev => ({
                    ...prev,
                    sku: productData.sku.trim() === '' && !isMainSkuManuallyEdited ? 'El SKU es obligatorio.' : '',
                    price: productData.price === '' || productData.price === null || productData.price === undefined ? 'Campo obligatorio.' : '',
                    stock: productData.stock === '' || productData.stock === null || productData.stock === undefined ? 'Campo obligatorio.' : '',
                    costPrice: productData.costPrice === '' || productData.costPrice === null || productData.costPrice === undefined ? 'Campo obligatorio.' : '',
                    unitOfMeasure: productData.unitOfMeasure.trim() === '' ? 'La unidad de medida es obligatoria.' : '',
                    // Limpiar errores de variantes si se cambia a producto simple
                    ...Object.keys(prev).filter(key => key.startsWith('variant-')).reduce((acc, key) => ({ ...acc, [key]: '' }), {})
                }));
                // Restablecer los valores a lo que el usuario pudo haber escrito antes
                setProductData(prev => ({
                    ...prev,
                    // Opcional: podrías restablecer stock/precio/costo a valores por defecto o al último valor que tenían
                    // si el usuario alternaba entre tipos de producto. Por ahora, asumimos que los dejará como estaban si no se modifican.
                }));
            } else { // Si se activa "tiene variantes"
                // Limpiar errores de campos de producto principal que se deshabilitan
                setFormErrors(prev => ({
                    ...prev,
                    sku: '', price: '', stock: '', costPrice: '', unitOfMeasure: ''
                }));
            }
        }

        // Lógica de autogeneración de SKU y sugerencias globales (solo para el campo 'name')
        if (name === 'name') {
            const generated = generateSkuFromName(inputValue);
            setAutoGeneratedSku(generated); // Siempre genera y actualiza el SKU autogenerado

            if (isNewProduct && inputValue.trim().length >= 2) {
                // Si el usuario no ha editado el SKU manualmente, el SKU del producto se actualiza para la previsualización
                // pero el valor real del input se dejará vacío para que el placeholder sea visible.
                if (!isMainSkuManuallyEdited) {
                    setProductData(prev => ({ ...prev, sku: '' })); // Mantener el valor vacío para que el placeholder se muestre
                }


                if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
                debounceTimeoutRef.current = setTimeout(async () => {
                    try {
                        const response = await axiosInstance.get(`/globalproducts?searchTerm=${inputValue}`);
                        if (response.data && response.data.length > 0) {
                            setGlobalProductSuggestions(response.data);
                            setShowGlobalSuggestions(true);
                            setNoGlobalSuggestionsFound(false);
                        } else {
                            setGlobalProductSuggestions([]);
                            setShowGlobalSuggestions(false);
                            setNoGlobalSuggestionsFound(true);
                        }
                    } catch (error) {
                        console.error('Error fetching global product suggestions:', error);
                        setGlobalProductSuggestions([]);
                        setShowGlobalSuggestions(false);
                        setNoGlobalSuggestionsFound(false);
                    }
                }, 300);
            } else if (isNewProduct && inputValue.trim().length < 2) {
                // Si el nombre es muy corto, limpiar SKU autogenerado y sugerencias
                setAutoGeneratedSku('');
                setProductData(prev => ({ ...prev, sku: '' })); // Asegurar que el SKU en el estado esté vacío
                setGlobalProductSuggestions([]);
                setShowGlobalSuggestions(false);
                setNoGlobalSuggestionsFound(false);
            }
        }

        // Lógica para detectar si el SKU principal fue editado manualmente
        if (name === 'sku') {
            if (inputValue.trim() !== '') {
                setIsMainSkuManuallyEdited(true); // El usuario ha introducido un valor manual
            } else {
                setIsMainSkuManuallyEdited(false); // El usuario ha borrado el valor, ya no es manual
                // No necesitamos regenerar autoGeneratedSku aquí; ya se hace en el 'name' input.
                // Aquí solo nos aseguramos de que el productData.sku refleje el input vacío.
            }
        }

        // Lógica de imagen URL si el input es imageUrl
        if (name === 'imageUrl') {
            setImageFile(null); // Si el usuario escribe una URL, borramos cualquier archivo cargado
            setImagePreviewUrl(inputValue);
        }

        // Después de actualizar el estado, validar el campo
        setFormErrors(prev => ({ ...prev, [name]: validateField(name, inputValue, { ...productData, [name]: inputValue }) }));

    }, [isNewProduct, isMainSkuManuallyEdited, generateSkuFromName, debounceTimeoutRef, validateField, productData, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setFormErrors]);

    // Maneja los cambios en los campos de entrada de las variantes del producto
    const handleVariantInputChange = useCallback((index, e) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedVariants = [...prev.variants];
            let updatedVariant = { ...updatedVariants[index], [name]: inputValue };

            // Lógica de generación de SKU para variantes
            if (name === 'name') {
                if (!updatedVariant.sku || updatedVariant.sku.trim() === '') {
                    updatedVariant.autoGeneratedVariantSku = generateSkuFromName(inputValue);
                } else {
                    updatedVariant.autoGeneratedVariantSku = ''; // Si el usuario pone un SKU manual, no hay autogenerado
                }
            } else if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    updatedVariant.autoGeneratedVariantSku = '';
                } else {
                    // Si el SKU se borra, y el nombre de la variante existe, regenerar
                    if (updatedVariant.name && updatedVariant.name.trim() !== '') {
                        updatedVariant.autoGeneratedVariantSku = generateSkuFromName(updatedVariant.name);
                    } else {
                        updatedVariant.autoGeneratedVariantSku = '';
                    }
                }
            }

            updatedVariants[index] = updatedVariant;
            return { ...prev, variants: updatedVariants };
        });

        // Validar el campo de la variante y actualizar los errores
        setFormErrors(prev => ({
            ...prev,
            [`variant-${index}-${name}`]: validateField(name, inputValue, { ...productData, variants: productData.variants.map((v, i) => i === index ? { ...v, [name]: inputValue } : v) }, index)
        }));

        displayMessage('', '');
    }, [generateSkuFromName, validateField, productData, displayMessage, setFormErrors]);

    // NUEVO: Manejador para el input de tipo 'file' de la imagen principal
    const handleMainImageFileChange = useCallback(async (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFile(file);
            setImagePreviewUrl(URL.createObjectURL(file));
            setProductData(prev => ({ ...prev, imageUrl: '' })); // Borrar cualquier URL si se carga un archivo
            setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            await uploadImageToCloud(file, false, null); // Sube la imagen automáticamente al seleccionar
        } else {
            setImageFile(null);
            setImagePreviewUrl(productData.imageUrl || ''); // Vuelve a la URL existente si no se selecciona nada
            setProductData(prev => ({ ...prev, imageUrl: productData.imageUrl || '' }));
        }
        displayMessage('', '');
    }, [productData.imageUrl, displayMessage, uploadImageToCloud, setFormErrors]);

    // NUEVO: Manejador para el evento onBlur del input de URL de imagen principal
    const handleMainImageUrlBlur = useCallback(async (e) => {
        const value = e.target.value;
        // Solo intenta subir si la URL no está vacía y ha cambiado, y no es una URL de Cloudinary ya
        if (value && value.trim() !== productData.imageUrl && !value.includes('res.cloudinary.com')) {
            await uploadImageToCloud(value, false, null); // Sube la URL al perder el foco
        }
    }, [productData.imageUrl, uploadImageToCloud]);


    // Maneja los cambios cuando se selecciona un archivo de imagen local para una variante
    const handleVariantImageFileChange = useCallback(async (index, e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadImageToCloud(file, true, index); // `true` para isVariant
        }
    }, [uploadImageToCloud]);


    // Añade una nueva variante al producto actual
    const handleAddVariant = useCallback(() => {
        const newVariant = {
            name: '', sku: '', price: '', costPrice: '', stock: '',
            unitOfMeasure: 'unidad', imageUrl: '', color: '', size: '', material: '',
            autoGeneratedVariantSku: '', // Se autogenerará si no se introduce
            isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
        };
        setProductData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    }, []);

    // Función para eliminar una variante por su índice.
    const handleRemoveVariant = useCallback((indexToRemove) => {
        setFormErrors(prevErrors => {
            const newErrors = { ...prevErrors };
            Object.keys(newErrors).forEach(key => {
                if (key.startsWith(`variant-${indexToRemove}-`)) {
                    delete newErrors[key];
                }
            });
            // Reajustar índices de errores si se elimina una variante intermedia
            const adjustedErrors = {};
            for (const key in newErrors) {
                const parts = key.split('-');
                if (parts[0] === 'variant' && parseInt(parts[1]) > indexToRemove) {
                    const newIndex = parseInt(parts[1]) - 1;
                    adjustedErrors[`variant-${newIndex}-${parts[2]}`] = newErrors[key];
                } else {
                    adjustedErrors[key] = newErrors[key];
                }
            }
            return adjustedErrors;
        });

        setProductData(prev => ({
            ...prev,
            variants: prev.variants.filter((_, index) => index !== indexToRemove)
        }));
    }, [setFormErrors]);

    // Función para validar todo el formulario de producto (producto principal y todas las variantes) antes del envío.
    const validateForm = useCallback((currentProductData) => {
        let errors = {};
        let isValid = true;

        // Determina el SKU final para el producto principal basado en la entrada del usuario o auto-generación
        // Ahora, si el usuario no ha editado manualmente y el campo está vacío, se usará el autoGeneratedSku
        const finalMainSku = isMainSkuManuallyEdited ? currentProductData.sku : (currentProductData.sku || autoGeneratedSku);


        // Validaciones del producto principal
        const fieldsToValidate = ['name', 'category', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'baseCurrency']; // <-- ¡AÑADIDO 'baseCurrency'
        if (currentProductData.isPerishable) {
            fieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
        }

        fieldsToValidate.forEach(fieldName => {
            let value = currentProductData[fieldName];
            // Para SKU, usar el SKU final calculado
            if (fieldName === 'sku') value = finalMainSku;

            const errorMsg = validateField(fieldName, value, currentProductData);
            if (errorMsg) {
                errors[fieldName] = errorMsg;
                isValid = false;
            }
        });

        // Validaciones de variantes
        currentProductData.variants.forEach((variant, index) => {
            const variantPrefix = `variant-${index}-`;
            const finalVariantSku = variant.sku.trim() === '' ? variant.autoGeneratedVariantSku : variant.sku;

            const variantFieldsToValidate = ['name', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold'];
            if (variant.isPerishable) {
                variantFieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
            }

            variantFieldsToValidate.forEach(fieldName => {
                let value = variant[fieldName];
                if (fieldName === 'sku') value = finalVariantSku;

                const errorMsg = validateField(fieldName, value, currentProductData, index);
                if (errorMsg) {
                    errors[`${variantPrefix}${fieldName}`] = errorMsg;
                    isValid = false;
                }
            });
        });

        setFormErrors(errors); // Actualiza el estado de los errores del formulario
        return isValid;
    }, [isNewProduct, autoGeneratedSku, validateField, setFormErrors, isMainSkuManuallyEdited]);


    const handleSubmit = useCallback(async (e) => {
        e.preventDefault();
        const isValid = validateForm(productData);
        if (!isValid) {
            displayMessage('Por favor, corrige los errores en el formulario.', 'error');
            return;
        }

        // Antes de guardar, asegurarse de que el SKU principal final sea el autogenerado si no fue editado
        const productDataToSend = { ...productData };
        if (isNewProduct && !isMainSkuManuallyEdited && productData.sku.trim() === '') {
            productDataToSend.sku = autoGeneratedSku;
        }


        await onProductSave(productDataToSend); // Llama al callback pasado por prop
    }, [onProductSave, productData, validateForm, displayMessage, isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]);


    // Maneja la selección de un producto desde las sugerencias del catálogo global.
    const handleSelectGlobalProduct = useCallback((suggestedProduct) => {
        setProductData(prev => ({ // Usar el actualizador de función para evitar dependencias circulares complejas
            ...prev, // Mantén otros campos que no se sobrescriben
            name: suggestedProduct.name,
            description: suggestedProduct.description || '',
            category: suggestedProduct.category || '',
            sku: suggestedProduct.sku || '',
            unitOfMeasure: suggestedProduct.unitOfMeasure || 'unidad',
            brand: suggestedProduct.brand || '',
            supplier: suggestedProduct.supplier || '',
            imageUrl: suggestedProduct.imageUrl || '',
            color: suggestedProduct.color || '',
            size: suggestedProduct.size || '',
            material: suggestedProduct.material || '',
            isPerishable: suggestedProduct.isPerishable || false,
            reorderThreshold: suggestedProduct.reorderThreshold || 0,
            optimalMaxStock: suggestedProduct.optimalMaxStock || 0,
            shelfLifeDays: suggestedProduct.shelfLifeDays || 0,
            baseCurrency: suggestedProduct.baseCurrency || 'USD', // <-- ¡AÑADE ESTO!
            variants: suggestedProduct.variants ? suggestedProduct.variants.map(v => ({
                ...v,
                autoGeneratedVariantSku: v.sku && v.sku.trim() !== '' ? '' : generateSkuFromName(v.name || ''),
                isPerishable: v.isPerishable || false,
                reorderThreshold: v.reorderThreshold || 0,
                optimalMaxStock: v.optimalMaxStock || 0,
                shelfLifeDays: v.shelfLifeDays || 0,
            })) : [],
        }));
        setImageFile(null); // Limpiar archivo local
        setImagePreviewUrl(suggestedProduct.imageUrl || ''); // Establecer previsualización de la URL del producto global
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setAutoGeneratedSku(suggestedProduct.name ? generateSkuFromName(suggestedProduct.name) : ''); // Regenerar SKU autogenerado para el nuevo nombre
        setIsMainSkuManuallyEdited(suggestedProduct.sku.trim() !== ''); // Si el producto global tiene SKU, se asume manual
        setFormErrors({}); // Limpiar errores al seleccionar sugerencia
    }, [generateSkuFromName, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setIsMainSkuManuallyEdited, setFormErrors]);


    return (
        <Suspense fallback={<div>Cargando formulario...</div>}>
            <AddEditProductFormUI
                isNewProduct={isNewProduct}
                productData={productData}
                onProductDataChange={setProductData} // Pasa el setter del estado local
                onSubmit={handleSubmit}
                loading={loading}
                displayMessage={displayMessage}
                autoGeneratedSku={autoGeneratedSku}
                isMainSkuManuallyEdited={isMainSkuManuallyEdited}
                setIsMainSkuManuallyEdited={setIsMainSkuManuallyEdited}
                imageFile={imageFile}
                setImageFile={setImageFile}
                imagePreviewUrl={imagePreviewUrl}
                setImagePreviewUrl={setImagePreviewUrl}
                isUploadingMainImage={isUploadingMainImage}
                variantImageUploading={variantImageUploading}
                setVariantImageUploading={setVariantImageUploading}
                uploadImageToCloud={uploadImageToCloud}
                unitOfMeasureOptions={unitOfMeasureOptions}
                formErrors={formErrors}
                setFormErrors={setFormErrors}
                generateSkuFromName={generateSkuFromName}
                globalProductSuggestions={globalProductSuggestions}
                showGlobalSuggestions={showGlobalSuggestions}
                setShowGlobalSuggestions={setShowGlobalSuggestions}
                setNoGlobalSuggestionsFound={setNoGlobalSuggestionsFound}
                noGlobalSuggestionsFound={noGlobalSuggestionsFound}
                handleSelectGlobalProduct={handleSelectGlobalProduct}
                debounceTimeoutRef={debounceTimeoutRef}
                setShowAdvancedOptions={setShowAdvancedOptions}
                showAdvancedOptions={showAdvancedOptions}
                // Props con los handlers completos para la UI
                handleAddVariant={handleAddVariant}
                handleRemoveVariant={handleRemoveVariant}
                handleProductInputChange={handleProductInputChange} // Pasa el handler completo
                handleVariantInputChange={handleVariantInputChange}
                handleMainImageFileChange={handleMainImageFileChange} // Pasa el handler de file
                handleMainImageUrlBlur={handleMainImageUrlBlur} // Pasa el handler de onBlur de URL
                handleVariantImageFileChange={handleVariantImageFileChange}
            />
        </Suspense>
    );
};

export default AddEditProductFormLogic;
// Nota: Este componente maneja la lógica del formulario de añadir/editar productos.
// Se encarga de la validación, subida de imágenes, sugerencias globales y gestión de variantes.