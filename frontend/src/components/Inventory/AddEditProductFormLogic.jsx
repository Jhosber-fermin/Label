// src/components/Inventory/AddEditProductFormLogic.jsx
import React, { useState, useEffect, useCallback, useRef, lazy, Suspense } from 'react';
import axiosInstance from '../../api/axiosInstance';
import { useCurrency } from '../../context/CurrencyContext'; // <-- ¡NUEVA LÍNEA!
import { useDebounce } from '../../hooks/useDebounce'; // Asumo que tienes este hook
import { useTranslation } from 'react-i18next'; // Asumo que tienes este hook
import PropTypes from 'prop-types'; // Asumo que tienes PropTypes
import { toast } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

// Importación perezosa del componente AddEditProductForm (ahora de UI)
const AddEditProductFormUI = lazy(() => import('./AddEditProductForm'));

// Define defaultNewProductState aquí, ya que es la base para la inicialización
const defaultNewProductState = {
    name: '', description: '', category: '', price: '', stock: '',
    costPrice: '', sku: '', unitOfMeasure: 'unidad', brand: '', supplier: '', imageUrl: '',
    color: '', size: '', material: '', variants: [],
    isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
    // Asegurarse de incluir los nuevos campos de moneda con valores por defecto
    costCurrency: 'USD', saleCurrency: 'USD', baseCurrency: 'USD', displayCurrency: 'USD',
};

const AddEditProductFormLogic = ({
    isNewProduct,
    initialProductData, // Producto inicial para edición o vacío para nuevo
    onProductSave, // Callback para InventoryPage (handleAddProduct o handleUpdateProduct)
    loading,
    displayMessage,
    unitOfMeasureOptions,
    debounceTimeoutRef, // Pasado desde InventoryPage para el debounce
}) => {
    // Usa el contexto de moneda y desestructura TODO lo que necesitas de una vez
    const { exchangeRate, convertPrice, formatPrice, baseCurrency: contextBaseCurrency, primaryCurrency, secondaryCurrency } = useCurrency(); // <-- ¡AÑADIDO formatPrice y convertPrice!

    // Estados internos para la lógica del formulario
    const [isEditing, setIsEditing] = useState(!isNewProduct);
    const [hasVariants, setHasVariants] = useState(initialProductData?.variants?.length > 0 || false);
    const [productData, setProductData] = useState(initialProductData);
    const [autoGeneratedSku, setAutoGeneratedSku] = useState('');
    const [isMainSkuManuallyEdited, setIsMainSkuManuallyEdited] = useState(false);
    const [globalProductSuggestions, setGlobalProductSuggestions] = useState([]);
    const [showGlobalSuggestions, setShowGlobalSuggestions] = useState(false);
    const [noGlobalSuggestionsFound, setNoGlobalSuggestionsFound] = useState(false);
    const [imageFile, setImageFile] = useState(null);
    const [imagePreviewUrl, setImagePreviewUrl] = useState('');
    const [isUploadingMainImage, setIsUploadingMainImage] = useState(false);
    const [variantImageUploading, setVariantImageUploading] = useState({});
    const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
    const [formErrors, setFormErrors] = useState({});

    // --- ESTADOS PARA PORCENTAJE DE GANANCIA DINÁMICO ---
    const [calculatedProductProfitPercentage, setCalculatedProductProfitPercentage] = useState(0);
    const [calculatedProductPricePlaceholder, setCalculatedProductPricePlaceholder] = useState(0);
    const [calculatedVariantProfitPercentage, setCalculatedVariantProfitPercentage] = useState({});
    const [calculatedVariantPricePlaceholder, setCalculatedVariantPricePlaceholder] = useState({});
    // --- FIN ESTADOS ---

    // Función para generar un SKU único a partir de un nombre
    const generateSkuFromName = useCallback((name) => {
        if (!name || name.trim() === '') return '';
        const cleanedName = name
            .normalize("NFD").replace(/[\u0300-\u036f]/g, "")
            .replace(/[^a-zA-Z0-9\s]/g, '')
            .trim()
            .toUpperCase()
            .split(/\s+/)
            .slice(0, 4)
            .join('-');
        const hash = Math.random().toString(36).substring(2, 6).toUpperCase();
        return `${cleanedName.substring(0, 15)}-${hash}`;
    }, []);

    // --- Función para subir imágenes a Cloudinary (y actualizar estado del producto) ---
    const uploadImageToCloud = useCallback(async (fileOrUrl, isVariant = false, variantIndex = null) => {
        let uploadedUrl = '';
        const formData = new FormData();

        setFormErrors(prev => {
            const newErrors = { ...prev };
            if (isVariant) {
                newErrors[`variant-${variantIndex}-imageUrl`] = '';
            } else {
                newErrors.imageUrl = '';
            }
            return newErrors;
        });

        if (isVariant) {
            setVariantImageUploading(prev => ({ ...prev, [variantIndex]: true }));
        } else {
            setIsUploadingMainImage(true);
        }

        try {
            if (typeof fileOrUrl === 'string') { // Es una URL, intentar subirla directamente si no es de Cloudinary
                if (fileOrUrl.includes('res.cloudinary.com')) {
                    uploadedUrl = fileOrUrl; // Ya es de Cloudinary, no subir de nuevo
                } else {
                    formData.append('imageUrl', fileOrUrl); // Backend lo manejará como URL
                    const response = await axiosInstance.post('/upload/url', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data', // Importante para FormData
                        },
                    });
                    uploadedUrl = response.data.url;
                }
            } else { // Es un objeto File (desde input type="file")
                formData.append('image', fileOrUrl); // 'image' debe coincidir con el nombre del campo en tu backend (uploadMiddleware)
                const response = await axiosInstance.post('/upload', formData, {
                    headers: {
                        'Content-Type': 'multipart/form-data', // Importante para FormData
                    },
                });
                uploadedUrl = response.data.url;
            }

            if (isVariant) {
                setProductData(prev => {
                    const updatedVariants = [...prev.variants];
                    updatedVariants[variantIndex] = { ...updatedVariants[variantIndex], imageUrl: uploadedUrl };
                    return { ...prev, variants: updatedVariants };
                });
                displayMessage('Imagen de variante subida exitosamente.', 'success');
            } else {
                setProductData(prev => ({ ...prev, imageUrl: uploadedUrl }));
                setImagePreviewUrl(uploadedUrl); // Actualiza la previsualización
                displayMessage('Imagen principal subida exitosamente.', 'success');
            }
            return uploadedUrl;
        } catch (err) {
            console.error('Error al subir imagen:', err.response?.data?.message || err.message);
            const errorMessage = err.response?.data?.message || 'Error al subir imagen. Inténtalo de nuevo.';
            displayMessage(errorMessage, 'error');
            setFormErrors(prev => {
                const newErrors = { ...prev };
                if (isVariant) {
                    newErrors[`variant-${variantIndex}-imageUrl`] = errorMessage;
                } else {
                    newErrors.imageUrl = errorMessage;
                }
                return newErrors;
            });
            return null;
        } finally {
            if (isVariant) {
                setVariantImageUploading(prev => ({ ...prev, [variantIndex]: false }));
            } else {
                setIsUploadingMainImage(false);
            }
        }
    }, [displayMessage, setFormErrors, setProductData, setImagePreviewUrl, setIsUploadingMainImage, setVariantImageUploading]);
    // --- FIN Función de Subida de Imágenes ---


    // Función auxiliar para calcular porcentaje de ganancia y precio placeholder
    const calculateProfitAndPricePlaceholder = useCallback((cost, currentPrice, costCurrency, saleCurrency, setPercentage, setPricePlaceholder) => {
        if (!exchangeRate || !exchangeRate.rate || isNaN(cost) || cost <= 0) {
            setPercentage(0);
            setPricePlaceholder(0);
            return;
        }

        const defaultProfit = exchangeRate.defaultProfitPercentage || 30;
        let calculatedPrice = 0;
        let calculatedPercentage = 0;

        // Convertir costo a la moneda de venta para calcular porcentaje
        // Si el costCurrency o saleCurrency son nulos o vacíos, usar la moneda base del exchangeRate
        const effectiveCostCurrency = costCurrency || exchangeRate.fromCurrency;
        const effectiveSaleCurrency = saleCurrency || exchangeRate.fromCurrency;

        const costInSaleCurrency = convertPrice(cost, effectiveCostCurrency, effectiveSaleCurrency);

        // Si tenemos un precio de venta actual, calculamos el porcentaje
        if (!isNaN(currentPrice) && currentPrice > 0 && costInSaleCurrency > 0) {
            calculatedPercentage = ((currentPrice - costInSaleCurrency) / costInSaleCurrency) * 100;
            calculatedPrice = currentPrice; // Si ya hay un precio válido, ese es el precio a usar
        } else {
            // Si no hay precio actual o es inválido, calculamos el precio basado en el porcentaje por defecto
            calculatedPrice = costInSaleCurrency * (1 + defaultProfit / 100);
            calculatedPercentage = defaultProfit;
        }
        
        setPercentage(calculatedPercentage.toFixed(2));
        setPricePlaceholder(calculatedPrice.toFixed(2));

    }, [exchangeRate, convertPrice]); // Depende de exchangeRate y convertPrice

    // **¡AQUÍ VA LA FUNCIÓN validateField! ¡ANTES DE LOS CALLBACKS QUE LA USAN!**
    const validateField = useCallback((name, value, currentProductState, variantIndex = null) => {
        let error = '';
        const isVariantField = variantIndex !== null;

        const isProductSimple = currentProductState.variants.length === 0;

        // Helper para obtener el valor correcto si es una variante
        const getVariantValue = (fieldName) => { // Función auxiliar interna, no afecta el bug
            if (isVariantField) {
                return currentProductState.variants[variantIndex][fieldName];
            }
            return value;
        };

        const currentFieldData = isVariantField ? currentProductState.variants[variantIndex] : currentProductState;


        // Validaciones generales
        if ((name === 'name' || name === 'category' || name === 'unitOfMeasure' || name === 'price' || name === 'stock' || name === 'costPrice' || name === 'sku' || name === 'baseCurrency' || name === 'costCurrency' || name === 'saleCurrency' || name === 'displayCurrency') &&
            ((isProductSimple && !isVariantField) || isVariantField)) {
            
            if (name === 'sku' && isNewProduct && !isMainSkuManuallyEdited && (value === '' || value === undefined || value === null)) {
                error = '';
            } else if (name === 'sku' && value.trim() === '') {
                error = 'El SKU es obligatorio.';
            } else if (name === 'name' && value.trim() === '') {
                error = 'El nombre es obligatorio.';
            } else if (name === 'category' && value.trim() === '') {
                error = 'La categoría es obligatoria.';
            } else if (name === 'unitOfMeasure' && value.trim() === '') {
                error = 'La unidad de medida es obligatoria.';
            } else if (name === 'price' && (value === '' || isNaN(Number(value)) || Number(value) <= 0)) {
                error = 'El precio de venta debe ser un número positivo.';
            } else if (name === 'costPrice' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El costo unitario debe ser un número no negativo.';
            } else if (name === 'stock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock debe ser un número no negativo.';
            } else if ((name === 'baseCurrency' || name === 'costCurrency' || name === 'saleCurrency' || name === 'displayCurrency') && value.trim() === '') {
                 error = 'La moneda es obligatoria.';
            }
        }
        
        // Validaciones específicas para perecederos
        if (currentFieldData.isPerishable) {
            if (name === 'optimalMaxStock' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
                error = 'El stock óptimo máximo debe ser un número no negativo.';
            }
            if (name === 'shelfLifeDays' && (value === '' || isNaN(Number(value)) || Number(value) <= 0)) {
                error = 'La vida útil debe ser un número positivo de días.';
            }
        }

        // Validación del umbral de reaprovisionamiento
        if (name === 'reorderThreshold' && (value === '' || isNaN(Number(value)) || Number(value) < 0)) {
            error = 'El umbral de reaprovisionamiento debe ser un número no negativo.';
        }

        // Validación para la URL de la imagen principal
        if (name === 'imageUrl' && value.trim() !== '' && !/^https?:\/\/.+\.(jpg|jpeg|png|gif|bmp|webp)$/i.test(value)) {
            error = 'La URL de la imagen no es válida.';
        }

        // Validación de unicidad de SKU (siempre al final para no interferir con otras validaciones)
        if (name === 'sku' && value.trim() !== '' && (isProductSimple || isVariantField)) {
            // Lógica de unicidad de SKU aquí (requiere llamada a API, se puede optimizar con debounce)
        }

        return error;
    }, [isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]);

    // Sincroniza el estado interno con las props iniciales (para edición o nuevo producto)
    useEffect(() => {
        setProductData(prevData => {
            const dataToSet = { ...initialProductData };
            
            // Asegurar que `initialProductData` esté completo para evitar `undefined` o `null`
            Object.keys(defaultNewProductState).forEach(key => { // <-- defaultNewProductState está aquí
                if (dataToSet[key] === undefined) {
                    dataToSet[key] = defaultNewProductState[key];
                }
            });

            // Inicializar las nuevas monedas si es un producto nuevo o no las tiene
            dataToSet.costCurrency = dataToSet.costCurrency || 'USD';
            dataToSet.saleCurrency = dataToSet.costCurrency; // ¡Modificación para que saleCurrency se adapte al costo!
            dataToSet.baseCurrency = dataToSet.baseCurrency || contextBaseCurrency || 'USD';
            dataToSet.displayCurrency = dataToSet.displayCurrency || dataToSet.saleCurrency || 'USD';

            // Asegurar que las variantes también tengan los nuevos campos de moneda inicializados
            dataToSet.variants = dataToSet.variants ? dataToSet.variants.map(v => ({
                ...v,
                costCurrency: v.costCurrency || 'USD',
                saleCurrency: v.costCurrency || 'USD', // ¡Modificación para que saleCurrency de variante se adapte al costo!
            })) : [];
            
            // Si es un producto con variantes, ciertos campos del padre deben ser informativos
            if (dataToSet.variants.length > 0) {
                dataToSet.stock = 0;
                dataToSet.price = 0;
                dataToSet.costPrice = 0;
            }

            return dataToSet;
        });

        // Sincronizar estados adicionales y generar SKU
        setImagePreviewUrl(initialProductData.imageUrl || '');
        setImageFile(null);
        setIsUploadingMainImage(false);
        setVariantImageUploading({});
        setShowAdvancedOptions(false);
        setFormErrors({});
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);

        setIsMainSkuManuallyEdited(initialProductData.sku?.trim() !== '');
        setAutoGeneratedSku(initialProductData.name ? generateSkuFromName(initialProductData.name) : '');

        // Calcular porcentajes y placeholders al cargar el producto para edición
        if (initialProductData.costPrice !== undefined && initialProductData.costPrice !== null && initialProductData.variants?.length === 0) {
            calculateProfitAndPricePlaceholder(
                Number(initialProductData.costPrice),
                Number(initialProductData.price),
                initialProductData.costCurrency || 'USD',
                initialProductData.saleCurrency || 'USD',
                setCalculatedProductProfitPercentage,
                setCalculatedProductPricePlaceholder
            );
        }
        const initialVariantPercentages = {};
        const initialVariantPlaceholders = {};
        initialProductData.variants?.forEach((v, idx) => {
            if (v.costPrice !== undefined && v.costPrice !== null) {
                calculateProfitAndPricePlaceholder(
                    Number(v.costPrice),
                    Number(v.price),
                    v.costCurrency || 'USD',
                    v.saleCurrency || 'USD',
                    (percentage, pricePlaceholder) => {
                        initialVariantPercentages[idx] = percentage;
                        initialVariantPlaceholders[idx] = pricePlaceholder;
                    }
                );
            }
        });
        setCalculatedVariantProfitPercentage(initialVariantPercentages);
        setCalculatedVariantPricePlaceholder(initialVariantPlaceholders);

        return () => {
            if (debounceTimeoutRef.current) clearTimeout(debounceTimeoutRef.current);
        };
    }, [initialProductData, isNewProduct, generateSkuFromName, contextBaseCurrency, calculateProfitAndPricePlaceholder, debounceTimeoutRef]);


    // Manejador general para inputs del producto principal (con toda la lógica)
    const handleProductInputChange = useCallback((e, fieldType = null) => {
        const { name, value, type, checked } = e.target;
        let inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedData = { ...prev, [name]: inputValue };

            // Lógica de autogeneración de precio de venta basado en costo y porcentaje de ganancia
            if (prev.variants.length === 0) { // Solo para productos simples
                let currentCost = name === 'costPrice' ? Number(inputValue) : Number(prev.costPrice);
                let currentPrice = name === 'price' ? Number(inputValue) : Number(prev.price);
                let currentCostCurrency = name === 'costCurrency' ? inputValue : prev.costCurrency;
                let currentSaleCurrency = name === 'saleCurrency' ? inputValue : prev.saleCurrency;
                let profitPercentageInput = name === 'profitPercentage' ? Number(inputValue) : calculatedProductProfitPercentage;

                if (name === 'costPrice' || name === 'costCurrency' || name === 'saleCurrency') {
                    calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, setCalculatedProductProfitPercentage, setCalculatedProductPricePlaceholder);
                    if (name === 'costCurrency' && (prev.saleCurrency === prev.costCurrency || !prev.saleCurrency)) { // Si cambias costCurrency y saleCurrency era igual o no definido
                        updatedData.saleCurrency = inputValue; // Actualiza saleCurrency también
                    }
                    if (name === 'costCurrency' && (prev.displayCurrency === prev.costCurrency || !prev.displayCurrency)) { // Si cambias costCurrency y displayCurrency era igual o no definido
                        updatedData.displayCurrency = inputValue; // Actualiza displayCurrency también
                    }
                } else if (name === 'price') {
                    calculateProfitAndPricePlaceholder(currentCost, Number(inputValue), currentCostCurrency, currentSaleCurrency, setCalculatedProductProfitPercentage, setCalculatedProductPricePlaceholder);
                } else if (name === 'profitPercentage') {
                    if (!isNaN(currentCost) && currentCost > 0) {
                        const costInSaleCurrency = convertPrice(currentCost, currentCostCurrency, currentSaleCurrency);
                        const newCalculatedPrice = costInSaleCurrency * (1 + profitPercentageInput / 100);
                        updatedData.price = newCalculatedPrice.toFixed(2);
                        setCalculatedProductPricePlaceholder(newCalculatedPrice.toFixed(2));
                    }
                    setCalculatedProductProfitPercentage(profitPercentageInput.toFixed(2));
                }
            }

            // Lógica para detectar si el SKU principal fue editado manualmente
            if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    setIsMainSkuManuallyEdited(true);
                } else {
                    setIsMainSkuManuallyEdited(false);
                }
            }
            
            // Lógica de imagen URL si el input es imageUrl
            if (name === 'imageUrl') {
                setImageFile(null);
                setImagePreviewUrl(inputValue);
            }

            return updatedData;
        });
        displayMessage('', '');
        setFormErrors(prev => ({ ...prev, [name]: '' }));
        setFormErrors(prev => ({ ...prev, [name]: validateField(name, inputValue, { ...productData, [name]: inputValue }, null) })); // Pasa null para variantIndex para producto principal

    }, [isNewProduct, isMainSkuManuallyEdited, generateSkuFromName, debounceTimeoutRef, validateField, productData, displayMessage, setGlobalProductSuggestions, setShowGlobalSuggestions, setNoGlobalSuggestionsFound, setImageFile, setImagePreviewUrl, setFormErrors, calculateProfitAndPricePlaceholder, convertPrice, calculatedProductProfitPercentage]);


    // Maneja los cambios en los campos de entrada de las variantes del producto
    const handleVariantInputChange = useCallback((index, e, fieldType = null) => {
        const { name, value, type, checked } = e.target;
        const inputValue = type === 'checkbox' ? checked : value;

        setProductData(prev => {
            const updatedVariants = [...prev.variants];
            let updatedVariant = { ...updatedVariants[index], [name]: inputValue };

            // Lógica de autogeneración de precio de venta para VARIANTE
            let currentCost = name === 'costPrice' ? Number(inputValue) : Number(updatedVariant.costPrice);
            let currentPrice = name === 'price' ? Number(inputValue) : Number(updatedVariant.price);
            let currentCostCurrency = name === 'costCurrency' ? inputValue : updatedVariant.costCurrency;
            let currentSaleCurrency = name === 'saleCurrency' ? inputValue : updatedVariant.saleCurrency;
            let profitPercentageInput = name === 'profitPercentage' ? Number(inputValue) : calculatedVariantProfitPercentage[index];

            if (name === 'costPrice' || name === 'costCurrency' || name === 'saleCurrency') {
                calculateProfitAndPricePlaceholder(currentCost, currentPrice, currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
                if (name === 'costCurrency' && (updatedVariant.saleCurrency === updatedVariant.costCurrency || !updatedVariant.saleCurrency)) {
                    updatedVariant.saleCurrency = inputValue;
                }
            } else if (name === 'price') {
                calculateProfitAndPricePlaceholder(currentCost, Number(inputValue), currentCostCurrency, currentSaleCurrency, (percentage, pricePlaceholder) => {
                    setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: percentage }));
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: pricePlaceholder }));
                });
            } else if (name === 'profitPercentage') {
                if (!isNaN(currentCost) && currentCost > 0) {
                    const costInSaleCurrency = convertPrice(currentCost, currentCostCurrency, currentSaleCurrency);
                    const newCalculatedPrice = costInSaleCurrency * (1 + profitPercentageInput / 100);
                    updatedVariant.price = newCalculatedPrice.toFixed(2);
                    setCalculatedVariantPricePlaceholder(prev => ({ ...prev, [index]: newCalculatedPrice.toFixed(2) }));
                }
                setCalculatedVariantProfitPercentage(prev => ({ ...prev, [index]: profitPercentageInput.toFixed(2) }));
            }

            // Lógica de generación de SKU para variantes (sin cambios aquí)
            if (name === 'name') {
                if (!updatedVariant.sku || updatedVariant.sku.trim() === '') {
                    updatedVariant.autoGeneratedVariantSku = generateSkuFromName(inputValue);
                } else {
                    updatedVariant.autoGeneratedVariantSku = '';
                }
            } else if (name === 'sku') {
                if (inputValue.trim() !== '') {
                    updatedVariant.autoGeneratedVariantSku = '';
                } else {
                    if (updatedVariant.name && updatedVariant.name.trim() !== '') {
                        updatedVariant.autoGeneratedVariantSku = generateSkuFromName(updatedVariant.name);
                    } else {
                        updatedVariant.autoGeneratedVariantSku = '';
                    }
                }
            }

            updatedVariants[index] = updatedVariant;
            return { ...prev, variants: updatedVariants };
        });

        setFormErrors(prev => ({
            ...prev,
            [`variant-${index}-${name}`]: validateField(name, inputValue, { ...productData, variants: productData.variants.map((v, i) => i === index ? { ...v, [name]: inputValue } : v) }, index)
        }));

        displayMessage('', '');
    }, [generateSkuFromName, validateField, productData, displayMessage, setFormErrors, calculateProfitAndPricePlaceholder, convertPrice, calculatedVariantProfitPercentage, calculatedVariantPricePlaceholder]);

    // NUEVO: Manejador para el input de tipo 'file' de la imagen principal
    const handleMainImageFileChange = useCallback(async (e) => {
        const file = e.target.files[0];
        if (file) {
            setImageFile(file);
            setImagePreviewUrl(URL.createObjectURL(file));
            setProductData(prev => ({ ...prev, imageUrl: '' })); // Borrar cualquier URL si se carga un archivo
            setFormErrors(prev => ({ ...prev, imageUrl: '' }));
            await uploadImageToCloud(file, false, null); // Sube la imagen automáticamente al seleccionar
        } else {
            setImageFile(null);
            setImagePreviewUrl(productData.imageUrl || ''); // Vuelve a la URL existente si no se selecciona nada
            setProductData(prev => ({ ...prev, imageUrl: productData.imageUrl || '' }));
        }
        displayMessage('', '');
    }, [productData.imageUrl, displayMessage, uploadImageToCloud, setFormErrors]);

    // NUEVO: Manejador para el evento onBlur del input de URL de imagen principal
    const handleMainImageUrlBlur = useCallback(async (e) => {
        const value = e.target.value;
        // Solo intenta subir si la URL no está vacía y ha cambiado, y no es una URL de Cloudinary ya
        if (value && value.trim() !== productData.imageUrl && !value.includes('res.cloudinary.com')) {
            await uploadImageToCloud(value, false, null); // Sube la URL al perder el foco
        }
    }, [productData.imageUrl, uploadImageToCloud]);


    // Maneja los cambios cuando se selecciona un archivo de imagen local para una variante
    const handleVariantImageFileChange = useCallback(async (index, e) => {
        const file = e.target.files[0];
        if (file) {
            await uploadImageToCloud(file, true, index); // `true` para isVariant
        }
    }, [uploadImageToCloud]);


    // Añade una nueva variante al producto actual
    const handleAddVariant = useCallback(() => {
        const newVariant = {
            name: '', sku: '', price: '', costPrice: '', stock: '',
            unitOfMeasure: 'unidad', imageUrl: '', color: '', size: '', material: '',
            autoGeneratedVariantSku: '', // Se autogenerará si no se introduce
            isPerishable: false, reorderThreshold: 0, optimalMaxStock: 0, shelfLifeDays: 0,
            costCurrency: productData.costCurrency || 'USD', // Hereda la moneda de costo del padre o USD
            saleCurrency: productData.saleCurrency || 'USD', // Hereda la moneda de venta del padre o USD
        };
        setProductData(prev => ({ ...prev, variants: [...prev.variants, newVariant] }));
    }, [productData.costCurrency, productData.saleCurrency]); // Dependencias para heredar monedas del padre

    // Función para eliminar una variante por su índice.
    const handleRemoveVariant = useCallback((indexToRemove) => {
        setFormErrors(prevErrors => {
            const newErrors = { ...prevErrors };
            Object.keys(newErrors).forEach(key => {
                if (key.startsWith(`variant-${indexToRemove}-`)) {
                    delete newErrors[key];
                }
            });
            // Reajustar índices de errores si se elimina una variante intermedia
            const adjustedErrors = {};
            for (const key in newErrors) {
                const parts = key.split('-');
                if (parts[0] === 'variant' && parseInt(parts[1]) > indexToRemove) {
                    const newIndex = parseInt(parts[1]) - 1;
                    adjustedErrors[`variant-${newIndex}-${parts[2]}`] = newErrors[key];
                } else {
                    adjustedErrors[key] = newErrors[key];
                }
            }
            return adjustedErrors;
        });

        setProductData(prev => ({
            ...prev,
            variants: prev.variants.filter((_, index) => index !== indexToRemove)
        }));
    }, [setFormErrors]);

    // Función para validar todo el formulario de producto (producto principal y todas las variantes) antes del envío.
    const validateForm = useCallback((currentProductData) => {
        let errors = {};
        let isValid = true;

        // Determina el SKU final para el producto principal basado en la entrada del usuario o auto-generación
        const finalMainSku = isMainSkuManuallyEdited ? currentProductData.sku : (currentProductData.sku || autoGeneratedSku);


        // Validaciones del producto principal
        const fieldsToValidate = ['name', 'category', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'baseCurrency', 'costCurrency', 'saleCurrency', 'displayCurrency'];
        if (currentProductData.isPerishable) {
            fieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
        }

        fieldsToValidate.forEach(fieldName => {
            let value = currentProductData[fieldName];
            // Para SKU, usar el SKU final calculado
            if (fieldName === 'sku') value = finalMainSku;

            const errorMsg = validateField(fieldName, value, currentProductData, null); // Pasa null para variantIndex para producto principal
            if (errorMsg) {
                errors[fieldName] = errorMsg;
                isValid = false;
            }
        });

        // Validaciones de variantes
        currentProductData.variants.forEach((variant, index) => {
            const variantPrefix = `variant-${index}-`;
            const finalVariantSku = variant.sku.trim() === '' ? variant.autoGeneratedVariantSku : variant.sku;

            const variantFieldsToValidate = ['name', 'sku', 'price', 'costPrice', 'stock', 'unitOfMeasure', 'reorderThreshold', 'costCurrency', 'saleCurrency'];
            if (variant.isPerishable) {
                variantFieldsToValidate.push('optimalMaxStock', 'shelfLifeDays');
            }

            variantFieldsToValidate.forEach(fieldName => {
                let value = variant[fieldName];
                if (fieldName === 'sku') value = finalVariantSku;

                const errorMsg = validateField(fieldName, value, currentProductData, index);
                if (errorMsg) {
                    errors[`${variantPrefix}${fieldName}`] = errorMsg;
                    isValid = false;
                }
            });
        });

        setFormErrors(errors);
        return isValid;
    }, [isNewProduct, autoGeneratedSku, validateField, setFormErrors, isMainSkuManuallyEdited]);


    const handleSubmit = useCallback(async (e) => {
        e.preventDefault();
        const isValid = validateForm(productData);
        if (!isValid) {
            displayMessage('Por favor, corrige los errores en el formulario.', 'error');
            return;
        }

        // Antes de guardar, asegurarse de que el SKU principal final sea el autogenerado si no fue editado
        const productDataToSend = { ...productData };
        if (isNewProduct && !isMainSkuManuallyEdited && productData.sku.trim() === '') {
            productDataToSend.sku = autoGeneratedSku;
        }


        await onProductSave(productDataToSend);
    }, [onProductSave, productData, validateForm, displayMessage, isNewProduct, isMainSkuManuallyEdited, autoGeneratedSku]);


    // Maneja la selección de un producto desde las sugerencias del catálogo global.
    const handleSelectGlobalProduct = useCallback((suggestedProduct) => {
        setProductData(prev => {
            const newProductData = {
                ...prev, // Mantén otros campos que no se sobrescriben
                name: suggestedProduct.name,
                description: suggestedProduct.description || '',
                category: suggestedProduct.category || '',
                sku: suggestedProduct.sku || '',
                unitOfMeasure: suggestedProduct.unitOfMeasure || 'unidad',
                brand: suggestedProduct.brand || '',
                supplier: suggestedProduct.supplier || '',
                imageUrl: suggestedProduct.imageUrl || '',
                color: suggestedProduct.color || '',
                size: suggestedProduct.size || '',
                material: suggestedProduct.material || '',
                isPerishable: suggestedProduct.isPerishable || false,
                reorderThreshold: suggestedProduct.reorderThreshold || 0,
                optimalMaxStock: suggestedProduct.optimalMaxStock || 0,
                shelfLifeDays: suggestedProduct.shelfLifeDays || 0,
                
                // Nuevos campos de moneda
                baseCurrency: suggestedProduct.baseCurrency || 'USD',
                costCurrency: suggestedProduct.costCurrency || 'USD',
                saleCurrency: suggestedProduct.saleCurrency || 'USD',
                displayCurrency: suggestedProduct.displayCurrency || suggestedProduct.saleCurrency || 'USD',

                // Porcentaje y precio placeholder (se recalcularán en el useEffect)
                price: suggestedProduct.price || '', // Mantener el precio del suggestedProduct
                costPrice: suggestedProduct.costPrice || '', // Mantener el costo del suggestedProduct

                variants: suggestedProduct.variants ? suggestedProduct.variants.map(v => ({
                    ...v,
                    autoGeneratedVariantSku: v.sku && v.sku.trim() !== '' ? '' : generateSkuFromName(v.name || ''),
                    isPerishable: v.isPerishable || false,
                    reorderThreshold: v.reorderThreshold || 0,
                    optimalMaxStock: v.optimalMaxStock || 0,
                    shelfLifeDays: v.shelfLifeDays || 0,
                    costCurrency: v.costCurrency || 'USD',
                    saleCurrency: v.costCurrency || 'USD', // Asegurarse que saleCurrency se adapte al costo de la variante
                })) : [],
            };

            return newProductData;
        });

        // Actualizar estados adicionales
        setIsEditing(false); // Al seleccionar un producto global, se asume que se está creando uno nuevo basado en él
        setIsNewProduct(true); // Se fuerza a modo "nuevo producto" al seleccionar uno global
        setImageFile(null);
        setImagePreviewUrl(suggestedProduct.imageUrl || '');
        setGlobalProductSuggestions([]);
        setShowGlobalSuggestions(false);
        setNoGlobalSuggestionsFound(false);
        setAutoGeneratedSku(suggestedProduct.name ? generateSkuFromName(suggestedProduct.name) : '');
        setIsMainSkuManuallyEdited(suggestedProduct.sku?.trim() !== '');
        setFormErrors({});
        displayMessage('Producto global cargado. Puedes modificarlo y guardarlo como nuevo.', 'info');
    }, [generateSkuFromName, displayMessage]);


     return (
        <Suspense fallback={<div>Cargando formulario...</div>}>
            <AddEditProductFormUI
                isNewProduct={isNewProduct}
                productData={productData}
                onProductDataChange={setProductData}
                onSubmit={handleSubmit}
                loading={loading}
                displayMessage={displayMessage}
                autoGeneratedSku={autoGeneratedSku}
                isMainSkuManuallyEdited={isMainSkuManuallyEdited}
                setIsMainSkuManuallyEdited={setIsMainSkuManuallyEdited}
                imageFile={imageFile}
                setImageFile={setImageFile}
                imagePreviewUrl={imagePreviewUrl}
                setImagePreviewUrl={setImagePreviewUrl}
                isUploadingMainImage={isUploadingMainImage}
                variantImageUploading={variantImageUploading}
                setVariantImageUploading={setVariantImageUploading}
                uploadImageToCloud={uploadImageToCloud}
                unitOfMeasureOptions={unitOfMeasureOptions}
                formErrors={formErrors}
                setFormErrors={setFormErrors}
                generateSkuFromName={generateSkuFromName}
                globalProductSuggestions={globalProductSuggestions}
                showGlobalSuggestions={showGlobalSuggestions}
                setShowGlobalSuggestions={setShowGlobalSuggestions}
                setNoGlobalSuggestionsFound={setNoGlobalSuggestionsFound}
                noGlobalSuggestionsFound={noGlobalSuggestionsFound}
                handleSelectGlobalProduct={handleSelectGlobalProduct}
                debounceTimeoutRef={debounceTimeoutRef}
                setShowAdvancedOptions={setShowAdvancedOptions}
                showAdvancedOptions={showAdvancedOptions}
                // Props con los handlers completos para la UI
                handleAddVariant={handleAddVariant}
                handleRemoveVariant={handleRemoveVariant}
                handleProductInputChange={handleProductInputChange}
                handleVariantInputChange={handleVariantInputChange}
                handleMainImageFileChange={handleMainImageFileChange}
                handleMainImageUrlBlur={handleMainImageUrlBlur}
                handleVariantImageFileChange={handleVariantImageFileChange}
                // NUEVAS PROPS PARA EL PORCENTAJE DINÁMICO
                calculatedProductProfitPercentage={calculatedProductProfitPercentage}
                calculatedProductPricePlaceholder={calculatedProductPricePlaceholder}
                calculatedVariantProfitPercentage={calculatedVariantProfitPercentage}
                calculatedVariantPricePlaceholder={calculatedVariantPricePlaceholder}
                // ¡ESTAS FALTABAN!
                formatPrice={formatPrice} // <-- ¡AÑADIDA!
                convertPrice={convertPrice} // <-- ¡AÑADIDA!
            />
        </Suspense>
    );
};

export default AddEditProductFormLogic;